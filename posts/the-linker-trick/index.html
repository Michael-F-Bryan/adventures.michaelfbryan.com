<!doctype html><html lang=en><head><title>Link Time Dependency Injection · Michael-F-Bryan
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Michael-F-Bryan"><meta name=description content="Have you ever been in a situation where, because of how the code is structured, it&rsquo;s practically impossible to inject a dependency into the component that needs it? Even global variables - ubiquitously reviled for their ability to do &ldquo;spooky action at a distance&rdquo; - weren&rsquo;t spooky enough.
In this article, I&rsquo;ll share a technique I discovered while working on a WebAssembly-based CAD package that allows for dependency injection at link time. This technique is particularly useful when traditional dependency injection methods aren&rsquo;t available or practical."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Link Time Dependency Injection"><meta name=twitter:description content="Have you ever been in a situation where, because of how the code is structured, it’s practically impossible to inject a dependency into the component that needs it? Even global variables - ubiquitously reviled for their ability to do “spooky action at a distance” - weren’t spooky enough.
In this article, I’ll share a technique I discovered while working on a WebAssembly-based CAD package that allows for dependency injection at link time. This technique is particularly useful when traditional dependency injection methods aren’t available or practical."><meta property="og:url" content="https://adventures.michaelfbryan.com/posts/the-linker-trick/"><meta property="og:site_name" content="Michael-F-Bryan"><meta property="og:title" content="Link Time Dependency Injection"><meta property="og:description" content="Have you ever been in a situation where, because of how the code is structured, it’s practically impossible to inject a dependency into the component that needs it? Even global variables - ubiquitously reviled for their ability to do “spooky action at a distance” - weren’t spooky enough.
In this article, I’ll share a technique I discovered while working on a WebAssembly-based CAD package that allows for dependency injection at link time. This technique is particularly useful when traditional dependency injection methods aren’t available or practical."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-30T12:59:58+08:00"><meta property="article:modified_time" content="2025-04-01T09:19:10+08:00"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Tips & Tricks"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Unsafe Rust"><link rel=canonical href=https://adventures.michaelfbryan.com/posts/the-linker-trick/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm+MTzNJdv80k+n0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/master.min.34be5ef36a820320661b4a8578382aba472d1a01092908eb30f0db81ec4031d4.css integrity="sha256-NL5e82qCAyBmG0qFeDgqukctGgEJKQjrMPDbgexAMdQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://adventures.michaelfbryan.com/>Michael-F-Bryan
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://adventures.michaelfbryan.com/posts/the-linker-trick/>Link Time Dependency Injection</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-03-30T12:59:58+08:00>March 30, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
7-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/architecture/>Architecture</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/tips--tricks/>Tips & Tricks</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/rust/>Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/unsafe-rust/>Unsafe Rust</a></span></div></div></header><div class=post-content><p>Have you ever been in a situation where, because of how the code is structured, it&rsquo;s practically impossible to inject a dependency into the component that needs it? Even global variables - ubiquitously reviled for their ability to do &ldquo;spooky action at a distance&rdquo; - weren&rsquo;t spooky enough.</p><p>In this article, I&rsquo;ll share a technique I discovered while working on a WebAssembly-based CAD package that allows for dependency injection at link time. This technique is particularly useful when traditional dependency injection methods aren&rsquo;t available or practical.</p><div class="notices note"><p>The code written in this article is available <a href=https://github.com/Michael-F-Bryan/fornjot-plugins class=external-link target=_blank rel=noopener>on GitHub</a>. Feel free to browse through and steal code or inspiration.</p><p>If you found this useful or spotted a bug in the article, let me know on the blog&rsquo;s <a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/issues class=external-link target=_blank rel=noopener>issue tracker</a>!</p><p>Please excuse any outdated comments about <code>wit-bindgen</code>. I wrote the bulk of this article back in 2022 but never got around to publishing it.</p></div><h2 id=the-problem>The Problem
<a class=heading-link href=#the-problem><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Let&rsquo;s start with a concrete example. Imagine you are designing a CAD package where people can provide custom parts using a DLL that the CAD package will load at runtime. The CAD package expects each DLL to have a function that can be called whenever the part should be generated, with the function signature looking something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>model</span>(args: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Arguments</span>) -&gt; <span style=color:#a6e22e>Shape</span>;
</span></span></code></pre></div><p>Where the <code>Arguments</code> and <code>Shape</code> types come from some code generator, and the only way you can make them ergonomic to use is if you add your own helper methods and trait implementations.</p><p>What you would really like to do is pull the generated code into a common crate that all implementations can import. This lets us hide the code generation step, allows reusing the pre-defined helper methods and trait implementations, and gives us a nice place to write examples and API docs.</p><p>This would normally be fine because you can define the types in some common crate and let the model author define the <code>model()</code> function (possibly enforcing the function signature via a macro), but there&rsquo;s a twist&mldr;</p><ol><li>Because &ldquo;reasons&rdquo;, the generated code requires our <code>model()</code> function to be defined in its parent module (i.e. somewhere in our common crate), and</li><li>The CAD package directly calls <code>model()</code> with no possibility for the model author to intercept the call or do some setup beforehand</li></ol><h2 id=why-traditional-solutions-dont-work>Why Traditional Solutions Don&rsquo;t Work
<a class=heading-link href=#why-traditional-solutions-dont-work><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Let&rsquo;s look at why our usual dependency injection techniques won&rsquo;t work here:</p><ol><li><p><strong>Direct Injection</strong>: We can&rsquo;t pass the implementation as an argument because the CAD package calls <code>model()</code> directly.</p></li><li><p><strong>Global Variables</strong>: Even if we used a global variable to store the implementation, we have no way to initialize it. This is because our &ldquo;DLL&rdquo; is actually a WebAssembly binary, and WebAssembly has no way to make sure a function is called when it is first loaded (i.e. we can&rsquo;t use <code>__attribute__(ctor)</code> or <a href=https://crates.io/crates/ctor class=external-link target=_blank rel=noopener>the <code>ctor</code> crate</a>).</p></li><li><p><strong>Runtime Registration</strong>: The <code>log</code> crate&rsquo;s pattern of having a <code>static</code> variable containing a function that gets set on startup won&rsquo;t work either, since we can&rsquo;t guarantee when or if initialization code will run.</p></li></ol><h2 id=the-solution-link-time-dependency-injection>The Solution: Link Time Dependency Injection
<a class=heading-link href=#the-solution-link-time-dependency-injection><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The solution comes from an unexpected place - the linker. This technique is actually quite common in C programs and is even used by Rust&rsquo;s standard library for the global allocator.</p><p>Let&rsquo;s look at how <a href=https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/library/alloc/src/alloc.rs#L22-L39 class=external-link target=_blank rel=noopener>Rust&rsquo;s <code>#[global_allocator]</code> attribute</a> works:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// library/alloc/src/alloc.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;Rust&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[rustc_allocator]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[rustc_allocator_nounwind]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__rust_alloc</span>(size: <span style=color:#66d9ef>usize</span>, align: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[rustc_allocator_nounwind]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__rust_dealloc</span>(ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u8</span>, size: <span style=color:#66d9ef>usize</span>, align: <span style=color:#66d9ef>usize</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[rustc_allocator_nounwind]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__rust_realloc</span>(ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u8</span>, old_size: <span style=color:#66d9ef>usize</span>, align: <span style=color:#66d9ef>usize</span>, new_size: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[rustc_allocator_nounwind]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__rust_alloc_zeroed</span>(size: <span style=color:#66d9ef>usize</span>, align: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>alloc</code> crate declares a bunch of <code>extern "Rust"</code> functions and some downstream crate provides the implementation, with all the nitty-gritty details hidden behind a macro.</p><div class="notices note"><p>It wasn&rsquo;t until after writing up most of this article that I realised I&rsquo;d read about this technique before.</p><p>In <em>Working Effectively With Legacy Code</em> there is a section called <em>Link Seams</em>,</p><blockquote><p>In many language systems, compilation isn&rsquo;t the last step of the build process. The compiler produces an intermediate representation of the code, and that representation contains calls to code in other files. Linkers combine these representations. They resolve each of the calls so that you can have a complete program at runtime.</p></blockquote><p>You can leverage this linking step to provide your own implementation for functions. In the book&rsquo;s case, it is primarily used to provide mocks and spies when trying to get some gnarly code under test, but it works equally well for splitting a dependency cycle.</p></div><h2 id=a-real-world-example>A Real-World Example
<a class=heading-link href=#a-real-world-example><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Let&rsquo;s look at how this technique is used in practice. At <a href=https://hotg.ai/ class=external-link target=_blank rel=noopener>Hammer of the Gods</a>, we developed a containerisation technology backed by WebAssembly which lets us compile various operations in a data processing pipeline once, then execute these operations on a variety of platforms (desktop, browser, mobile, etc.)<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>A key part of this is <a href=https://github.com/bytecodealliance/wit-bindgen class=external-link target=_blank rel=noopener>the <code>wit-bindgen</code> project</a> which lets us define host and guest interfaces in <code>*.wit</code> files, then generate Rust code that satisfies the interfaces. If you are familiar with gRPC and Protocol Buffers, <code>wit-bindgen</code> is like <code>protoc</code> and <code>*.wit</code> files are like <code>*.proto</code> files.</p><p>We&rsquo;ve got 30+ different operations and it would be really nice if we could put the generated glue code in one common crate. That way we can add nice things like constructors, helper methods, and trait implementations to the generated types, wire up nicer error handling with the <code>?</code> operator, and so on.</p><p>Here&rsquo;s how we use link time dependency injection to solve this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// support/src/guest/bindings.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;Rust&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__proc_block_metadata</span>() -&gt; <span style=color:#a6e22e>Metadata</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__proc_block_new</span>(
</span></span><span style=display:flex><span>        args: Vec<span style=color:#f92672>&lt;</span>Argument<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    ) -&gt; Result<span style=color:#f92672>&lt;</span>Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> ProcBlock<span style=color:#f92672>&gt;</span>, CreateError<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ProcBlockV2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> proc_block_v2::ProcBlockV2 <span style=color:#66d9ef>for</span> ProcBlockV2 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>metadata</span>() -&gt; <span style=color:#a6e22e>Metadata</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>crate</span>::guest::ensure_initialized();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> { __proc_block_metadata() }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>create_node</span>(
</span></span><span style=display:flex><span>        args: Vec<span style=color:#f92672>&lt;</span>Argument<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    ) -&gt; Result<span style=color:#f92672>&lt;</span>wit_bindgen_rust::Handle<span style=color:#f92672>&lt;</span>self::Node<span style=color:#f92672>&gt;</span>, CreateError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>crate</span>::guest::ensure_initialized();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> proc_block <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { __proc_block_new(args)<span style=color:#f92672>?</span> };
</span></span><span style=display:flex><span>        Ok(Handle::new(Node(Box::new(proc_block))))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And a downstream crate provides the implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// argmax/src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>hotg_rune_proc_blocks::export_proc_block! {
</span></span><span style=display:flex><span>  metadata: <span style=color:#a6e22e>metadata</span>,
</span></span><span style=display:flex><span>  proc_block: <span style=color:#a6e22e>ArgMax</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, Default, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ArgMax</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Argument<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>for</span> ArgMax {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(_: Vec<span style=color:#f92672>&lt;</span>Argument<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> { ArgMax }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>metadata</span>() -&gt; <span style=color:#a6e22e>Metadata</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> ProcBlock <span style=color:#66d9ef>for</span> ArgMax {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>tensor_constraints</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>TensorConstraints</span> { <span style=color:#f92672>..</span>. }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(<span style=color:#f92672>&amp;</span>self, inputs: Vec<span style=color:#f92672>&lt;</span>Tensor<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Tensor<span style=color:#f92672>&gt;</span>, RunError<span style=color:#f92672>&gt;</span> { <span style=color:#f92672>..</span>. }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The macro that makes this work is also <a href=https://github.com/hotg-ai/proc-blocks/blob/f776393c60d4c53483d2d633bb7f73006598fda4/support/src/guest/macros.rs class=external-link target=_blank rel=noopener>part of the support crate</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// support/src/guest/macros.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Tell the runtime that a WebAssembly module contains a proc-block.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[macro_export]</span>
</span></span><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> export_proc_block {
</span></span><span style=display:flex><span>    (metadata: <span style=color:#75715e>$metadata_func</span>:<span style=color:#a6e22e>expr</span>, proc_block: <span style=color:#75715e>$proc_block</span>:<span style=color:#a6e22e>ty</span> <span style=color:#75715e>$(,</span>)<span style=color:#f92672>?</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[doc(hidden)]</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__proc_block_metadata</span>() -&gt; <span style=color:#75715e>$crate</span>::guest::Metadata { <span style=color:#75715e>$metadata_func</span>() }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[doc(hidden)]</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>__proc_block_new</span>(
</span></span><span style=display:flex><span>            args: Vec<span style=color:#f92672>&lt;</span><span style=color:#75715e>$crate</span>::guest::Argument<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        ) -&gt; Result<span style=color:#f92672>&lt;</span>Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> <span style=color:#75715e>$crate</span>::guest::ProcBlock<span style=color:#f92672>&gt;</span>, <span style=color:#75715e>$crate</span>::guest::CreateError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>assert_impl_proc_block</span>(_: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>impl</span> <span style=color:#75715e>$crate</span>::guest::ProcBlock) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> proc_block <span style=color:#f92672>=</span> <span style=color:#f92672>&lt;</span><span style=color:#75715e>$proc_block</span><span style=color:#f92672>&gt;</span>::try_from(args)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            assert_impl_proc_block(<span style=color:#f92672>&amp;</span>proc_block);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Ok(Box::new(proc_block) <span style=color:#66d9ef>as</span> Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> <span style=color:#75715e>$crate</span>::guest::ProcBlock<span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=when-should-you-use-this-trick>When Should You Use This Trick?
<a class=heading-link href=#when-should-you-use-this-trick><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>This technique should be used as a last resort, after considering these alternatives:</p><ol><li><strong>Pass Implementation as Arguments</strong>: If you have control over how/when your code is called, this is the cleanest solution.</li><li><strong>Runtime Registration</strong>: If you can run some code on startup, use a global variable (like the <code>log</code> crate does).</li><li><strong>Crate Links</strong>: If you can guarantee only one version of your crate will be in the crate graph, you might be able to use the <code>links</code> key in <code>Cargo.toml</code>.</li><li><strong>Static Linking</strong>: If everything is statically linked and compiled together, you might be able to use unstable ABI features.</li></ol><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Link time dependency injection is a powerful technique that can help break dependency cycles and provide implementations where traditional dependency injection methods aren&rsquo;t available. While it should be used sparingly and as a last resort, it&rsquo;s a valuable tool to have in your arsenal when dealing with complex architectural challenges.</p><p>The technique isn&rsquo;t novel - it&rsquo;s used extensively in C programs and is even employed by Rust&rsquo;s standard library for the global allocator. As mentioned in <em>Working Effectively with Legacy Code</em>, this pattern is known as &ldquo;Link Seams&rdquo; and is particularly useful when you need to provide alternative implementations without modifying the original code.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>For example, imagine making a pipeline which takes an audio clip, normalises the volume level, converts the audio samples into a spectrum, then passes the spectrum to a ML model which can recognise particular words. Each of these steps is compiled into its own WebAssembly module and our &ldquo;runtime&rdquo; chains them together. We also use the <a href=https://wapm.io/ class=external-link target=_blank rel=noopener><em>WebAssembly Package Manager</em></a> to distribute WebAssembly modules and manage versions.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2025
Michael-F-Bryan
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.
[<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/tree/dbb621a9a787b276f42c0f30165783a6aa3065a6 target=_blank rel=noopener>dbb621a</a>]</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=/js/mermaid.min.min.9c343a21d2c1c6ad2ffc2661e9409225290bf15165a7661b9149c9a03934034c.js integrity="sha256-nDQ6IdLBxq0v/CZh6UCSJSkL8VFlp2YbkUnJoDk0A0w="></script><script src=/js/index.min.c04ed42ce6cde47e0926ae55f072b1ff2e67af9e681a00d0ffe507800d3fd657.js integrity="sha256-wE7ULObN5H4JJq5V8HKx/y5nr55oGgDQ/+UHgA0/1lc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M80ZBKQHKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M80ZBKQHKV")}</script></body></html>