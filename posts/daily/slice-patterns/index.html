<!doctype html><html lang=en><head><title>Daily Rust: Slice Patterns · Michael-F-Bryan
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Michael-F-Bryan"><meta name=description content="Rust 1.26 introduced a nifty little feature called Basic Slice
Patterns which lets you pattern match on slices with a known length. Later on
in Rust 1.42, this was extended to allow using .. to match on
&ldquo;everything else&rdquo;.
As features go this may seem like a small addition, but it gives developers an
opportunity to write much more expressive code.


    The code written in this article is available in the various playground links
dotted throughout. Feel free to browse through and steal code or inspiration."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Daily Rust: Slice Patterns"><meta name=twitter:description content="Rust 1.26 introduced a nifty little feature called Basic Slice Patterns which lets you pattern match on slices with a known length. Later on in Rust 1.42, this was extended to allow using .. to match on “everything else”.
As features go this may seem like a small addition, but it gives developers an opportunity to write much more expressive code.
The code written in this article is available in the various playground links dotted throughout. Feel free to browse through and steal code or inspiration."><meta property="og:url" content="https://adventures.michaelfbryan.com/posts/daily/slice-patterns/"><meta property="og:site_name" content="Michael-F-Bryan"><meta property="og:title" content="Daily Rust: Slice Patterns"><meta property="og:description" content="Rust 1.26 introduced a nifty little feature called Basic Slice Patterns which lets you pattern match on slices with a known length. Later on in Rust 1.42, this was extended to allow using .. to match on “everything else”.
As features go this may seem like a small addition, but it gives developers an opportunity to write much more expressive code.
The code written in this article is available in the various playground links dotted throughout. Feel free to browse through and steal code or inspiration."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-01T09:19:10+08:00"><meta property="article:tag" content="Daily Rust"><meta property="article:tag" content="Rust"><meta property="og:see_also" content="https://adventures.michaelfbryan.com/posts/daily/iterators/"><link rel=canonical href=https://adventures.michaelfbryan.com/posts/daily/slice-patterns/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm+MTzNJdv80k+n0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/master.min.34be5ef36a820320661b4a8578382aba472d1a01092908eb30f0db81ec4031d4.css integrity="sha256-NL5e82qCAyBmG0qFeDgqukctGgEJKQjrMPDbgexAMdQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://adventures.michaelfbryan.com/>Michael-F-Bryan
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://adventures.michaelfbryan.com/posts/daily/slice-patterns/>Daily Rust: Slice Patterns</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2021-08-14T00:00:00Z>August 14, 2021
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
4-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/daily-rust/>Daily Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/rust/>Rust</a></span></div></div></header><div class=post-content><p><a href=https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#basic-slice-patterns class=external-link target=_blank rel=noopener>Rust 1.26</a> introduced a nifty little feature called <em>Basic Slice
Patterns</em> which lets you pattern match on slices with a known length. Later on
in <a href=https://blog.rust-lang.org/2020/03/12/Rust-1.42.html#subslice-patterns class=external-link target=_blank rel=noopener>Rust 1.42</a>, this was extended to allow using <code>..</code> to match on
&ldquo;everything else&rdquo;.</p><p>As features go this may seem like a small addition, but it gives developers an
opportunity to write much more expressive code.</p><div class="notices note"><p>The code written in this article is available in the various playground links
dotted throughout. Feel free to browse through and steal code or inspiration.</p><p>If you found this useful or spotted a bug in the article, let me know on the
blog&rsquo;s <a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/issues class=external-link target=_blank rel=noopener>issue tracker</a>!</p></div><h2 id=handling-plurality>Handling Plurality
<a class=heading-link href=#handling-plurality><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>One of the simplest applications of slice patterns is to provide user-friendly
messages by matching on fixed length slices.</p><p>Often it&rsquo;s nice to be able to customise your wording depending on whether there
were 0, 1, or many items. For example, this snippet&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_words</span>(sentence: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> words: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> sentence.split_whitespace().collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> words.as_slice() {
</span></span><span style=display:flex><span>        [] <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;There were no words&#34;</span>),
</span></span><span style=display:flex><span>        [word] <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Found 1 word: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, word),
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Found </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> words: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, words.len(), words),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    print_words(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>    print_words(<span style=color:#e6db74>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>    print_words(<span style=color:#e6db74>&#34;Hello World!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b5f39a8f3b759134bc1b5f1ccf71b58e" class=external-link target=_blank rel=noopener>(playground)</a></p><p>&mldr; will generate this output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>There were no words
</span></span><span style=display:flex><span>Found 1 word: Hello
</span></span><span style=display:flex><span>Found 2 words: [&#34;Hello&#34;, &#34;World!&#34;]
</span></span></code></pre></div><h2 id=matching-the-start-of-a-slice>Matching the Start of a Slice
<a class=heading-link href=#matching-the-start-of-a-slice><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The <code>..</code> syntax is called a &ldquo;rest&rdquo; pattern and lets you match on (surprise,
surprise) the rest of the slice.</p><p>According to the <a href=https://en.wikipedia.org/wiki/Executable_and_Linkable_Format class=external-link target=_blank rel=noopener>ELF Format</a>, all ELF binaries must start with the
sequence <code>0x7f ELF</code>. We can use this fact and rest patterns to implement our
own <code>is_elf()</code> check.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::error::Error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_elf</span>(binary: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> binary {
</span></span><span style=display:flex><span>        [<span style=color:#ae81ff>0x7f</span>, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;E&#39;</span>, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;L&#39;</span>, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;F&#39;</span>, <span style=color:#f92672>..</span>] <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Error<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> current_exe <span style=color:#f92672>=</span> std::env::current_exe()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> binary <span style=color:#f92672>=</span> std::fs::read(<span style=color:#f92672>&amp;</span>current_exe)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_elf(<span style=color:#f92672>&amp;</span>binary) {
</span></span><span style=display:flex><span>        print!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> is an ELF binary&#34;</span>, current_exe.display());
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        print!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> is NOT an ELF binary&#34;</span>, current_exe.display());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f26b605fc432a06fb062ebe56fee289f" class=external-link target=_blank rel=noopener>(playground)</a></p><h2 id=checking-for-palindromes>Checking for Palindromes
<a class=heading-link href=#checking-for-palindromes><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>A very common introductory challenge in programming is to write a check for
palindromes.</p><p>We can use the fact that the <code>@</code> symbols binds a new variable to whatever it
matches, and our ability to match on both the start and end of a slice to
create a particularly elegant <code>is_palindrome()</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_palindrome</span>(items: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>char</span>]) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> items {
</span></span><span style=display:flex><span>        [first, middle <span style=color:#f92672>@</span> <span style=color:#f92672>..</span>, last] <span style=color:#f92672>=&gt;</span> first <span style=color:#f92672>==</span> last <span style=color:#f92672>&amp;&amp;</span> is_palindrome(middle),
</span></span><span style=display:flex><span>        [] <span style=color:#f92672>|</span> [_] <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=baeec729aea945d2cd98387d1333ba8f" class=external-link target=_blank rel=noopener>(playground)</a></p><h2 id=a-poor-mans-argument-parser>A Poor Man&rsquo;s Argument Parser
<a class=heading-link href=#a-poor-mans-argument-parser><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Another way you might want to use slice patterns is by &ldquo;peeling off&rdquo; desired
prefixes or suffixes.</p><p>Although more sophisticated crates like <a href=https://crates.io/crates/clap class=external-link target=_blank rel=noopener><code>clap</code></a> and
<a href=https://crates.io/crates/structopt class=external-link target=_blank rel=noopener><code>structopt</code></a> exist, we can use this to implement our own basic
argument parser.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_args</span>(<span style=color:#66d9ef>mut</span> args: <span style=color:#66d9ef>&amp;</span>[<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>]) -&gt; <span style=color:#a6e22e>Args</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> input <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;input.txt&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> args {
</span></span><span style=display:flex><span>            [<span style=color:#e6db74>&#34;-h&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;--help&#34;</span>, <span style=color:#f92672>..</span>] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                eprintln!(<span style=color:#e6db74>&#34;Usage: main [--input &lt;filename&gt;] [--count &lt;count&gt;] &lt;args&gt;...&#34;</span>);
</span></span><span style=display:flex><span>                std::process::exit(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            [<span style=color:#e6db74>&#34;-i&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;--input&#34;</span>, filename, rest <span style=color:#f92672>@</span> <span style=color:#f92672>..</span>] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                input <span style=color:#f92672>=</span> filename.to_string();
</span></span><span style=display:flex><span>                args <span style=color:#f92672>=</span> rest;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            [<span style=color:#e6db74>&#34;-c&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;--count&#34;</span>, c, rest <span style=color:#f92672>@</span> <span style=color:#f92672>..</span>] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                count <span style=color:#f92672>=</span> c.parse().unwrap();
</span></span><span style=display:flex><span>                args <span style=color:#f92672>=</span> rest;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            [<span style=color:#f92672>..</span>] <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>break</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> positional_args <span style=color:#f92672>=</span> args.iter().map(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> s.to_string()).collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Args {
</span></span><span style=display:flex><span>        input,
</span></span><span style=display:flex><span>        count,
</span></span><span style=display:flex><span>        positional_args,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Args</span> {
</span></span><span style=display:flex><span>    input: String,
</span></span><span style=display:flex><span>    count: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    positional_args: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=aa016782dab527e80014c932fb769734" class=external-link target=_blank rel=noopener>(playground)</a></p><h2 id=irrefutable-pattern-matching>Irrefutable Pattern Matching
<a class=heading-link href=#irrefutable-pattern-matching><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Although not technically part of the <em>Slice Patterns</em> feature, you can use
pattern matching to destructure fixed arrays outside of a <code>match</code> or <code>if let</code>
statement.</p><p>This can be useful in avoiding clunkier sequences based on indices which will
never fail.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>format_coordinates</span>([x, y]: [<span style=color:#66d9ef>f32</span>; <span style=color:#ae81ff>2</span>]) -&gt; String {
</span></span><span style=display:flex><span>    format!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>|</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> point <span style=color:#f92672>=</span> [<span style=color:#ae81ff>3.14</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>42.0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, format_coordinates(point));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> [x, y] <span style=color:#f92672>=</span> point;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;x: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, y: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Much more ergonomic than writing this!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// let x = point[0];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// let y = point[1];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=dfbcc3a1bcf3545e3a15fedd57abe8cd" class=external-link target=_blank rel=noopener>(playground)</a></p><h2 id=conclusions>Conclusions
<a class=heading-link href=#conclusions><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>As far as features go in Rust slice patterns aren&rsquo;t overly complex but when used
appropriately, they can really improve the expressiveness of your code.</p><p>This was a lot shorter than my usual deep dives, but hopefully you learned
something new. Going forward I&rsquo;m hoping to create more of these <em>Daily Rust</em>
posts, copying shamelessly from Jonathan Boccara&rsquo;s <a href=https://www.fluentcpp.com/2017/04/04/the-dailies-a-new-way-to-learn-at-work/ class=external-link target=_blank rel=noopener>Daily C++</a>.</p></div><footer><section class=see-also></section></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2025
Michael-F-Bryan
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.
[<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/tree/dbb621a9a787b276f42c0f30165783a6aa3065a6 target=_blank rel=noopener>dbb621a</a>]</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=/js/mermaid.min.min.9c343a21d2c1c6ad2ffc2661e9409225290bf15165a7661b9149c9a03934034c.js integrity="sha256-nDQ6IdLBxq0v/CZh6UCSJSkL8VFlp2YbkUnJoDk0A0w="></script><script src=/js/index.min.c04ed42ce6cde47e0926ae55f072b1ff2e67af9e681a00d0ffe507800d3fd657.js integrity="sha256-wE7ULObN5H4JJq5V8HKx/y5nr55oGgDQ/+UHgA0/1lc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M80ZBKQHKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M80ZBKQHKV")}</script></body></html>