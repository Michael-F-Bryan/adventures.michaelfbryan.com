<!doctype html><html lang=en><head><title>Daily Rust: Iterators · Michael-F-Bryan
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Michael-F-Bryan"><meta name=description content="Iterators are part of Rust&rsquo;s secret sauce. They power things from the humble
for-loop to the elegant iterator chain, but have you ever stopped to think how
they work?
Let&rsquo;s find out more about Rust&rsquo;s iterators by implementing our own versions of
common iterators and reading the standard library&rsquo;s source code.


    The code written in this article is available on the Rust Playground using the
various (playground) links dotted throughout. Feel free to browse
through and steal code or inspiration."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Daily Rust: Iterators"><meta name=twitter:description content="Iterators are part of Rust’s secret sauce. They power things from the humble for-loop to the elegant iterator chain, but have you ever stopped to think how they work?
Let’s find out more about Rust’s iterators by implementing our own versions of common iterators and reading the standard library’s source code.
The code written in this article is available on the Rust Playground using the various (playground) links dotted throughout. Feel free to browse through and steal code or inspiration."><meta property="og:url" content="https://adventures.michaelfbryan.com/posts/daily/iterators/"><meta property="og:site_name" content="Michael-F-Bryan"><meta property="og:title" content="Daily Rust: Iterators"><meta property="og:description" content="Iterators are part of Rust’s secret sauce. They power things from the humble for-loop to the elegant iterator chain, but have you ever stopped to think how they work?
Let’s find out more about Rust’s iterators by implementing our own versions of common iterators and reading the standard library’s source code.
The code written in this article is available on the Rust Playground using the various (playground) links dotted throughout. Feel free to browse through and steal code or inspiration."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-24T03:55:00+08:00"><meta property="article:modified_time" content="2025-04-01T09:19:10+08:00"><meta property="article:tag" content="Daily Rust"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Iterators"><meta property="og:see_also" content="https://adventures.michaelfbryan.com/posts/daily/slice-patterns/"><link rel=canonical href=https://adventures.michaelfbryan.com/posts/daily/iterators/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm+MTzNJdv80k+n0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/master.min.34be5ef36a820320661b4a8578382aba472d1a01092908eb30f0db81ec4031d4.css integrity="sha256-NL5e82qCAyBmG0qFeDgqukctGgEJKQjrMPDbgexAMdQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://adventures.michaelfbryan.com/>Michael-F-Bryan
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://adventures.michaelfbryan.com/posts/daily/iterators/>Daily Rust: Iterators</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2021-08-24T03:55:00+08:00>August 24, 2021
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
8-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/daily-rust/>Daily Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/rust/>Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/iterators/>Iterators</a></span></div></div></header><div class=post-content><p>Iterators are part of Rust&rsquo;s secret sauce. They power things from the humble
for-loop to the elegant iterator chain, but have you ever stopped to think how
they work?</p><p>Let&rsquo;s find out more about Rust&rsquo;s iterators by implementing our own versions of
common iterators and reading the standard library&rsquo;s source code.</p><div class="notices info"><p>The code written in this article is available on the Rust Playground using the
various <a href=https://play.rust-lang.org/ class=external-link target=_blank rel=noopener>(playground)</a> links dotted throughout. Feel free to browse
through and steal code or inspiration.</p><p>If you found this useful or spotted a bug in the article, let me know on the
blog&rsquo;s <a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/issues class=external-link target=_blank rel=noopener>issue tracker</a>!</p></div><h2 id=the-iterator-trait>The Iterator Trait
<a class=heading-link href=#the-iterator-trait><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>At its most simplest, an iterator is just something with a <code>next()</code> method that
may return some <code>Item</code> or <code>None</code>.</p><p>This is all encapsulated in the <a href=https://github.com/rust-lang/rust/blob/73d96b090bb68065cd3a469b27cbd568e39bf0e7/library/core/src/iter/traits/iterator.rs#L55-L92 class=external-link target=_blank rel=noopener><code>std::iter::Iterator</code></a> trait, with
the definition looking something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>trait</span> Iterator {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now you may be wondering why most Rust code doesn&rsquo;t have calls to <code>next()</code>
scattered throughout, and that&rsquo;s where <a href=https://en.wikipedia.org/wiki/Syntactic_sugar class=external-link target=_blank rel=noopener><em>Syntactic Sugar</em></a>
comes in. This is where the compiler will see certain high level constructs in
your code and transform them into a lower level form.</p><p>The humble for-loop is probably the most familiar instance of this syntactic
sugar.</p><p>For example, when the compiler sees this&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> item <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, item);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; the code will be transformed into this&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> iterator <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span>).into_iter();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(item) <span style=color:#f92672>=</span> iterator.next() {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, item);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9c2994be6caac61c54698b2e5adf9f94" class=external-link target=_blank rel=noopener>(playground)</a></p><p>What this does is turn the range expression, <code>0..5</code>, into an iterator and then
keep calling its <code>next()</code> method until we get <code>None</code>.</p><div class="notices note"><p>This <code>into_iter()</code> method (backed by the <a href=https://doc.rust-lang.org/std/iter/trait.IntoIterator.html class=external-link target=_blank rel=noopener><code>std::iter::IntoIterator</code></a>
trait) is a way to transform something into an iterator.</p><p>Some common types that implement <code>IntoIterator</code> are <a href=https://github.com/rust-lang/rust/blob/73d96b090bb68065cd3a469b27cbd568e39bf0e7/library/alloc/src/vec/mod.rs#L2489-L2529 class=external-link target=_blank rel=noopener><code>Vec&lt;T></code></a>,
<a href=https://github.com/rust-lang/rust/blob/73d96b090bb68065cd3a469b27cbd568e39bf0e7/library/core/src/option.rs#L1660-L1682 class=external-link target=_blank rel=noopener><code>Option&lt;T></code></a>, and most importantly, <a href=https://github.com/rust-lang/rust/blob/73d96b090bb68065cd3a469b27cbd568e39bf0e7/library/core/src/iter/traits/collect.rs#L237-L246 class=external-link target=_blank rel=noopener>anything implementing
the <code>Iterator</code> trait</a> (which will just return itself).</p><p>This trait comes in handy because it often means you can use a collection in a
for-loop without needing to call some <code>iter()</code> method, because most collections
have an <code>IntoIterator</code> implementation which will pull items out of the
collection until there is nothing left (at which point the collection is
destroyed).</p></div><h2 id=fibonacci>Fibonacci
<a class=heading-link href=#fibonacci><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Now we have some basic familiarity with iterators, let&rsquo;s create our own iterator
over all the Fibonacci numbers that fit into a <code>u32</code>.</p><p>First we&rsquo;ll create a new <code>Fibonacci</code> type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Fibonacci</span> {
</span></span><span style=display:flex><span>    a: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    b: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then we implement the <code>Iterator</code> trait. The idea is that each call to <code>next()</code>
will do just enough work to generate the next number in the sequence.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Iterator <span style=color:#66d9ef>for</span> Fibonacci {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to add &#34;a&#34; and &#34;b&#34;, returning None if the addition would
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// overflow to signal that we&#39;ve reached the end of the sequence.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> next_term <span style=color:#f92672>=</span> self.a.checked_add(self.b)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.a <span style=color:#f92672>=</span> self.b;
</span></span><span style=display:flex><span>        self.b <span style=color:#f92672>=</span> next_term;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Some(next_term)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices note"><p>You&rsquo;ll notice we use the <a href=https://doc.rust-lang.org/std/primitive.u32.html#method.checked_add class=external-link target=_blank rel=noopener><code>checked_add()</code></a> method here instead of
the normal <code>+</code> operator. This is important because we are working with
fixed-size integers and we need a stopping condition.</p><p>Without it, we would reach <code>2_971_215_073</code> and either panic (in debug mode)
overflow (in release mode). This is Rust&rsquo;s way of telling us that we if we are
creating bigger and bigger numbers we should handle the situation when our
numbers get too big for the integer type we are using.</p></div><p>Now all we need is a helper function to create a <code>Fibonacci</code> object with our
initial conditions and a <code>main()</code> function that uses it in a loop and we&rsquo;re
good to go.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fibonacci_numbers</span>() -&gt; <span style=color:#a6e22e>Fibonacci</span> {
</span></span><span style=display:flex><span>    Fibonacci { a: <span style=color:#ae81ff>1</span>, b: <span style=color:#ae81ff>0</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> number <span style=color:#66d9ef>in</span> fibonacci_numbers() {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, number);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5ecf8f52253983fabe7b24edc2ed6c8d" class=external-link target=_blank rel=noopener>(playground)</a></p><p>Strictly speaking the helper function wasn&rsquo;t really necessary, but it helps make
the code cleaner and means readers won&rsquo;t see <code>Fibonacci { a: 1, b: 0 }</code> and
wonder where we pulled those magic numbers from.</p><p>Alternatively, we could have implemented the <code>Default</code> trait.</p><h2 id=iterating-over-a-slice>Iterating Over a Slice
<a class=heading-link href=#iterating-over-a-slice><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Iterators are commonly used to inspect the items in a collection. The simplest
collection type is a slice, so let&rsquo;s create our own version of
<a href=https://doc.rust-lang.org/std/slice/struct.Iter.html class=external-link target=_blank rel=noopener><code>std::slice::Iter</code></a>.</p><p>First we need a struct which keeps track of the slice and the index of the next
item to read.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SliceIter</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    slice: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [T],
</span></span><span style=display:flex><span>    index: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our implementation then just uses <a href=https://doc.rust-lang.org/std/primitive.slice.html#method.get class=external-link target=_blank rel=noopener>the slice&rsquo;s <code>get()</code> method</a> to get
the item at that index or <code>None</code> if the index is past the end of the slice. We
then just use <code>?</code> to return <code>None</code> if there was no item, then increment our
<code>index</code> before yielding the item to the caller.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> SliceIter<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> T;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> item <span style=color:#f92672>=</span> self.slice.get(self.index)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        self.index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Some(item)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=ab2183b26e3a10c63e2b4c60a7843cb2" class=external-link target=_blank rel=noopener>(playground)</a></p><div class="notices info"><p>For the curious, I&rsquo;ve also implemented <a href="https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=420278dbeec26f0c560f9b1b13612922" class=external-link target=_blank rel=noopener>an <code>unsafe</code> version</a>. I&rsquo;ll leave
comparing the two for performance as an exercise for the reader, but gut feel
says they&rsquo;ll be identical.</p><p>I&rsquo;d love you to prove me wrong and explain why on Reddit or the user forums,
though 😉</p></div><p>Just for fun, here is a cute version based on <a href=https://adventures.michaelfbryan.com/posts/daily/slice-patterns/ class=external-link target=_blank rel=noopener><em>Slice Patterns</em></a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SliceIter</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    slice: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [T],
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> SliceIter<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> T;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.slice {
</span></span><span style=display:flex><span>            [first, rest <span style=color:#f92672>@</span> <span style=color:#f92672>..</span>] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                self.slice <span style=color:#f92672>=</span> rest;
</span></span><span style=display:flex><span>                Some(first)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            [] <span style=color:#f92672>=&gt;</span> None,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0fcc643b63d1d1718170ee2b4389fbfd" class=external-link target=_blank rel=noopener>(playground)</a></p><h2 id=filter>Filter
<a class=heading-link href=#filter><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>One of the most commonly used iterator combinators is <a href=https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter class=external-link target=_blank rel=noopener><code>filter()</code></a>, a
combinator which takes an iterator and a predicate and only yields items where
that predicate returns <code>true</code>.</p><p>You often see it used like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> even_numbers <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>10</span>).filter(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> n <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> number <span style=color:#66d9ef>in</span> even_numbers {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, number);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=add1a5b92871b9162b4de061976393b3" class=external-link target=_blank rel=noopener>(playground)</a></p><p>We get the following output, as expected:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>0
</span></span><span style=display:flex><span>2
</span></span><span style=display:flex><span>4
</span></span><span style=display:flex><span>6
</span></span><span style=display:flex><span>8
</span></span></code></pre></div><p>Now, let&rsquo;s write our own implementation!</p><p>First we&rsquo;ll need a <code>Filter</code> type and some way of constructing it. For ergonomics,
you would normally create an extension trait with a <code>fn filter()</code> method that
returns <code>Filter</code> and implement that for all iterators, but we&rsquo;ll be lazy and
just write a function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Filter</span><span style=color:#f92672>&lt;</span>I, F<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    iter: <span style=color:#a6e22e>I</span>,
</span></span><span style=display:flex><span>    predicate: <span style=color:#a6e22e>F</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>filter</span><span style=color:#f92672>&lt;</span>I, F<span style=color:#f92672>&gt;</span>(iter: <span style=color:#a6e22e>I</span>, predicate: <span style=color:#a6e22e>F</span>) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> I::Item<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Filter { iter, predicate }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices tip"><p>In this situation we&rsquo;ve chosen to use <code>impl Trait</code> for the return value instead
of providing an explicit type.</p><p>The <code>Filter</code> struct is just an implementation detail, and not necessarily one we
want people to code against or make public, so we make the concrete type
unnameable.</p></div><p>Now we obviously need to implement the <code>Iterator</code> trait on <code>Filter</code>.</p><p>The naive implementation would look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>I, F<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> Filter<span style=color:#f92672>&lt;</span>I, F<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: Iterator,
</span></span><span style=display:flex><span>    F: FnMut(<span style=color:#f92672>&amp;</span>I::Item) -&gt; <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> I::Item;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> item <span style=color:#f92672>=</span> self.iter.next()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (self.predicate)(<span style=color:#f92672>&amp;</span>item) {
</span></span><span style=display:flex><span>            Some(item)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            None
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>filter</span><span style=color:#f92672>&lt;</span>I, F<span style=color:#f92672>&gt;</span>(iter: <span style=color:#a6e22e>I</span>, predicate: <span style=color:#a6e22e>F</span>) -&gt; <span style=color:#a6e22e>impl</span> Iterator<span style=color:#f92672>&lt;</span>Item <span style=color:#f92672>=</span> I::Item<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: IntoIterator,
</span></span><span style=display:flex><span>    F: FnMut(<span style=color:#f92672>&amp;</span>I::Item) -&gt; <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Filter {
</span></span><span style=display:flex><span>        iter: <span style=color:#a6e22e>iter</span>.into_iter(),
</span></span><span style=display:flex><span>        predicate,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=518ed8c15e89a1807ac1c8881211e7a1" class=external-link target=_blank rel=noopener>(playground)</a></p><div class="notices tip"><p>You might have noticed we chose to accept a <code>FnMut</code> closure for our predicate
instead of a plain <code>Fn</code>. This lets our closure carry mutable state across calls
and enables complex patterns like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Lorem ipsum dolor sit amet, consectetur adipiscing elit&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> letter_m_threshold <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> everything_before_the_3rd_word_containing_m <span style=color:#f92672>=</span> filter(
</span></span><span style=display:flex><span>    text.split_whitespace(),
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>word<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> word.contains(<span style=color:#e6db74>&#34;m&#34;</span>) {
</span></span><span style=display:flex><span>            letter_m_threshold  <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        letter_m_threshold <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> got: Vec<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> everything_before_the_3rd_word_containing_m .collect();
</span></span><span style=display:flex><span>assert_eq!(got, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#34;Lorem&#34;</span>, <span style=color:#e6db74>&#34;ipsum&#34;</span>, <span style=color:#e6db74>&#34;dolor&#34;</span>, <span style=color:#e6db74>&#34;sit&#34;</span>]);
</span></span></code></pre></div><p>Similarly, we choose to pass in an <code>&amp;I::Item</code> because we want to give the
predicate access to the item, but it shouldn&rsquo;t be given ownership (because then
our iterator has nothing to yield) or allowed to mutate the item.</p></div><p>You can see we pull the next item out of the inner iterator (using <code>?</code> to return
<code>None</code> if there are no more items), then we call the predicate function provided
by the user to check whether we should yield the item.</p><p>However, there is a small issue&mldr; Check out the output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>0
</span></span></code></pre></div><p>We&rsquo;re stopping after the first <code>false</code> item!</p><p>What we actually need to do is write a loop which keeps pulling items out of
the iterator until the predicate is satisfied.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>I, F<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> Filter<span style=color:#f92672>&lt;</span>I, F<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    I: Iterator,
</span></span><span style=display:flex><span>    F: FnMut(<span style=color:#f92672>&amp;</span>I::Item) -&gt; <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> I::Item;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(item) <span style=color:#f92672>=</span> self.iter.next() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (self.predicate)(<span style=color:#f92672>&amp;</span>item) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Some(item);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3b8b02131aa32684e23c048ec07cd92d" class=external-link target=_blank rel=noopener>(playground)</a></p><h2 id=conclusions>Conclusions
<a class=heading-link href=#conclusions><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>We&rsquo;ve barely scratched the surface on what iterators can achieve, but hopefully
you&rsquo;ll now have an understanding of how iterator combinators like <code>filter()</code> and
<code>map()</code> are implemented.</p><p>Iterators may touch on some higher-level topics like closures, associated types,
and syntactic sugar, but they aren&rsquo;t magic. Plus, when in doubt you can always
just <a href=https://github.com/rust-lang/rust/tree/73d96b090bb68065cd3a469b27cbd568e39bf0e7/library/std/src class=external-link target=_blank rel=noopener>read the source</a>.</p></div><footer><section class=see-also></section></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2025
Michael-F-Bryan
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.
[<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/tree/dbb621a9a787b276f42c0f30165783a6aa3065a6 target=_blank rel=noopener>dbb621a</a>]</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=/js/mermaid.min.min.9c343a21d2c1c6ad2ffc2661e9409225290bf15165a7661b9149c9a03934034c.js integrity="sha256-nDQ6IdLBxq0v/CZh6UCSJSkL8VFlp2YbkUnJoDk0A0w="></script><script src=/js/index.min.c04ed42ce6cde47e0926ae55f072b1ff2e67af9e681a00d0ffe507800d3fd657.js integrity="sha256-wE7ULObN5H4JJq5V8HKx/y5nr55oGgDQ/+UHgA0/1lc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M80ZBKQHKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M80ZBKQHKV")}</script></body></html>