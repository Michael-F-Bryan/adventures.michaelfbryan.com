<!doctype html><html lang=en><head><title>WebAssembly as a Platform for Abstraction · Michael-F-Bryan
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Michael-F-Bryan"><meta name=description content="In a project I&rsquo;ve been playing around with recently, we&rsquo;ve encountered the
dilemma where you want to make it easy for users to write their own
application logic using the system but at the same time want to keep that logic
decoupled from the implementation details of whatever platform the
application is running on.
If you&rsquo;ve been programming for any amount of time your immediate reaction is
probably &ldquo;why bother mentioning this, doesn&rsquo;t it just fall out of good
library design?&rdquo;, and normally I would totally agree with you, except I
forgot to mention a couple of important details&mldr;"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="WebAssembly as a Platform for Abstraction"><meta name=twitter:description content="In a project I’ve been playing around with recently, we’ve encountered the dilemma where you want to make it easy for users to write their own application logic using the system but at the same time want to keep that logic decoupled from the implementation details of whatever platform the application is running on.
If you’ve been programming for any amount of time your immediate reaction is probably “why bother mentioning this, doesn’t it just fall out of good library design?”, and normally I would totally agree with you, except I forgot to mention a couple of important details…"><meta property="og:url" content="https://adventures.michaelfbryan.com/posts/wasm-as-a-platform-for-abstraction/"><meta property="og:site_name" content="Michael-F-Bryan"><meta property="og:title" content="WebAssembly as a Platform for Abstraction"><meta property="og:description" content="In a project I’ve been playing around with recently, we’ve encountered the dilemma where you want to make it easy for users to write their own application logic using the system but at the same time want to keep that logic decoupled from the implementation details of whatever platform the application is running on.
If you’ve been programming for any amount of time your immediate reaction is probably “why bother mentioning this, doesn’t it just fall out of good library design?”, and normally I would totally agree with you, except I forgot to mention a couple of important details…"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-15T11:55:00+08:00"><meta property="article:modified_time" content="2025-04-01T09:19:10+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="WebAssembly"><link rel=canonical href=https://adventures.michaelfbryan.com/posts/wasm-as-a-platform-for-abstraction/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm+MTzNJdv80k+n0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/master.min.34be5ef36a820320661b4a8578382aba472d1a01092908eb30f0db81ec4031d4.css integrity="sha256-NL5e82qCAyBmG0qFeDgqukctGgEJKQjrMPDbgexAMdQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://adventures.michaelfbryan.com/>Michael-F-Bryan
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://adventures.michaelfbryan.com/posts/wasm-as-a-platform-for-abstraction/>WebAssembly as a Platform for Abstraction</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2019-12-15T11:55:00+08:00>December 15, 2019
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
36-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/rust/>Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/webassembly/>WebAssembly</a></span></div></div></header><div class=post-content><p>In a project I&rsquo;ve been playing around with recently, we&rsquo;ve encountered the
dilemma where you want to make it easy for users to write their own
application logic using the system but at the same time want to keep that logic
decoupled from the implementation details of whatever platform the
application is running on.</p><p>If you&rsquo;ve been programming for any amount of time your immediate reaction is
probably <em>&ldquo;why bother mentioning this, doesn&rsquo;t it just fall out of good
library design?&rdquo;</em>, and normally I would totally agree with you, except I
forgot to mention a couple of important details&mldr;</p><ol><li>People need to be able to upload new code while the system is still running</li><li>This application will be interacting with the real world (think robots and
automation), and we <em>really</em> don&rsquo;t want a crash in user-provided code to
make the entire system stop responding</li></ol><p>The normal solution for the first point is to use some sort of <a href=https://adventures.michaelfbryan.com/posts/plugins-in-rust/>plugin
architecture</a>, however using something like <em>Dynamic Loading</em>
doesn&rsquo;t solve the second point and the large amounts of <code>unsafe</code> code needed
can arguably make the situation worse. For that we&rsquo;ll need some sort of
sandboxing mechanism.</p><p>Introducing&mldr;</p><figure><a href=https://webassembly.org/><img src=https://webassembly.org/css/webassembly.svg alt="Web Assembly Logo" width=50%></a></figure><p>Web Assembly has gained a lot of traction over the last couple of years as a way
to write code in any language and run it in the browser, but it can be used for
so much more.</p><p>There are already <a href=https://github.com/wasmerio/wasmer class=external-link target=_blank rel=noopener>several</a> <a href=https://github.com/bytecodealliance/lucet class=external-link target=_blank rel=noopener>general-purpose</a>
<a href=https://github.com/bytecodealliance/wasmtime class=external-link target=_blank rel=noopener>runtimes</a> available for running Wasm in a Rust program. These
runtimes give you a virtual machine which can run arbitrary code, and the
only way this code can interact with the outside world is via the functions you
explicitly give it access to.</p><div class="notices note"><p>Unfortunately, the code behind this post isn&rsquo;t publicly available (yet!). It&rsquo;s
actually part of a larger project I&rsquo;ve been experimenting with and the final
version will probably end up quite different to what you see here.</p><p>That said, feel free to copy code or use it as inspiration for your own
projects. If you found this useful or spotted a bug, let me know on the
blog&rsquo;s <a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com class=external-link target=_blank rel=noopener>issue tracker</a>!</p></div><h2 id=getting-started>Getting Started
<a class=heading-link href=#getting-started><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>I&rsquo;ve chosen to use the <a href=https://github.com/wasmerio/wasmer class=external-link target=_blank rel=noopener><code>wasmer</code></a> crate because its interface seems to
be the most amenable to embedding.</p><p>Let&rsquo;s start things off by creating a new crate for the project.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo new --lib wasm
</span></span><span style=display:flex><span>     Created library `wasm` package
</span></span></code></pre></div><p>We&rsquo;ll also want to add the <code>wasmer-runtime</code> as a dependency.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cd wasm <span style=color:#f92672>&amp;&amp;</span> cargo add wasmer-runtime
</span></span><span style=display:flex><span>    Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
</span></span><span style=display:flex><span>      Adding wasmer-runtime v0.11.0 to dependencies
</span></span></code></pre></div><div class="notices tip"><p>You may have noticed I&rsquo;m using <code>cargo add</code> here instead of manually editing
the <code>Cargo.toml</code> file. You can get this nifty little subcommand from the
<a href=https://crates.io/crates/cargo-edit class=external-link target=_blank rel=noopener>cargo-edit</a> crate (<code>cargo install cargo-edit</code>).</p></div><p>Let&rsquo;s start off by creating a wrapper around an instantiated Wasm module.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> wasmer_runtime::error::Error <span style=color:#66d9ef>as</span> WasmerError;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// A user-provided program loaded into memory.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Program</span> {
</span></span><span style=display:flex><span>    instance: <span style=color:#a6e22e>wasmer_runtime</span>::Instance,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Program {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(wasm: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>]) -&gt; Result<span style=color:#f92672>&lt;</span>Self, WasmerError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> imports <span style=color:#f92672>=</span> wasmer_runtime::imports!();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> instance <span style=color:#f92672>=</span> wasmer_runtime::instantiate(wasm, <span style=color:#f92672>&amp;</span>imports)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(Program { instance })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We just want to get things running, so for now we won&rsquo;t bother exposing any
host functions to the user-provided program. Hence the empty <code>imports!()</code> call.</p><p>Motion control systems typically work by rapidly polling each task in turn,
so let&rsquo;s give <code>Program</code> a <code>poll()</code> method which will call the Wasm module&rsquo;s
<code>poll()</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Program {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Result<span style=color:#f92672>&lt;</span>(), WasmerError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.instance.call(<span style=color:#e6db74>&#34;poll&#34;</span>, <span style=color:#f92672>&amp;</span>[])<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Technically we now have everything necessary to load and poll a program, so
let&rsquo;s give it a shot. We&rsquo;ll need to create an executable and our project
could do with an example showing how to run a program, so we should be able to
kill two birds with one stone.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// examples/basic-runtime.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> wasm::Program;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::{env, error::Error};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Error<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> wasm_file <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> env::args().skip(<span style=color:#ae81ff>1</span>).next() {
</span></span><span style=display:flex><span>        Some(filename) <span style=color:#f92672>=&gt;</span> filename,
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> panic!(<span style=color:#e6db74>&#34;Usage: basic-runtime &lt;wasm-file&gt;&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> wasm <span style=color:#f92672>=</span> std::fs::read(<span style=color:#f92672>&amp;</span>wasm_file)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> program <span style=color:#f92672>=</span> Program::load(<span style=color:#f92672>&amp;</span>wasm)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        program.poll()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ll also need a dummy program that can be compiled to Wasm and fed to our
<code>basic-runtime</code> example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// example-program.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>() {}
</span></span></code></pre></div><p>Now we should be able to compile the <code>example-program.rs</code> to Wasm and run it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ rustc example-program.rs --target wasm32-unknown-unknown --crate-type cdylib
</span></span><span style=display:flex><span>$ ls
</span></span><span style=display:flex><span>Cargo.toml  example-program.rs  example_program.wasm  examples  src
</span></span><span style=display:flex><span>$ cargo run --example basic-runtime -- example_program.wasm
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.21s
</span></span><span style=display:flex><span>     Running `/home/michael/Documents/wasm/target/debug/examples/basic-runtime example_program.wasm`
</span></span><span style=display:flex><span>^C
</span></span></code></pre></div><p>Well that was&mldr; anticlimatic. The <code>poll()</code> function in <code>example-program.rs</code>
doesn&rsquo;t actually do anything, so we just created an expensive busy loop.</p><p>Let&rsquo;s give the Wasm code a way to print messages to the screen.</p><p>The way this is done is via that <code>imports!()</code> macro from earlier, basically
any function defined inside <code>imports!()</code> is accessible to the Wasm code.
<code>wasmer</code> imposes some strict constraints on the functions which may be exposed
to Wasm, restricting arguments and return values to <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>,
and pointers.</p><p>Functions may optionally accept a <code>&amp;mut wasmer_runtime::Ctx</code> as the first
argument, this is useful for interacting with the runtime (e.g. to access
Wasm memory or call a function) or accessing contextual information attached
to the <code>Instance</code>.</p><p>The code itself is rather straightforward:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Program {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(wasm: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>]) -&gt; Result<span style=color:#f92672>&lt;</span>Self, WasmerError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> imports <span style=color:#f92672>=</span> wasmer_runtime::imports! {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;env&#34;</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;print&#34;</span> <span style=color:#f92672>=&gt;</span> wasmer_runtime::func!(print),
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> instance <span style=color:#f92672>=</span> wasmer_runtime::instantiate(wasm, <span style=color:#f92672>&amp;</span>imports)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(Program { instance })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Result<span style=color:#f92672>&lt;</span>(), WasmerError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.instance.call(<span style=color:#e6db74>&#34;poll&#34;</span>, <span style=color:#f92672>&amp;</span>[])<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Print the provided message to the screen.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>///
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// Returns `-1` if the operation failed.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print</span>(ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx, msg: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>, length: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> msg.get_utf8_string(ctx.memory(<span style=color:#ae81ff>0</span>), length) {
</span></span><span style=display:flex><span>        Some(msg) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            print!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, msg);
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can update the <code>example-program.rs</code> file to print <code>"Polling"</code> every time
it gets called.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// example-program.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Print a message to the screen.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>///
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// Returns -1 if the operation fails.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print</span>(msg: <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>u8</span>, length: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> msg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Polling</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        print(msg.as_bytes().as_ptr(), msg.len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We should now be able to recompile and run the program again.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>$</span> rustc example<span style=color:#f92672>-</span>program.rs <span style=color:#f92672>--</span>target wasm32<span style=color:#f92672>-</span>unknown<span style=color:#f92672>-</span>unknown <span style=color:#f92672>--</span><span style=color:#66d9ef>crate</span><span style=color:#f92672>-</span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>cdylib</span>
</span></span><span style=display:flex><span><span style=color:#75715e>$</span> cargo run <span style=color:#f92672>--</span>example basic<span style=color:#f92672>-</span>runtime <span style=color:#f92672>--</span> example_program.wasm
</span></span><span style=display:flex><span>Polling
</span></span><span style=display:flex><span>Polling
</span></span><span style=display:flex><span>Polling
</span></span><span style=display:flex><span>Polling
</span></span><span style=display:flex><span>Polling
</span></span><span style=display:flex><span><span style=color:#f92672>^</span>C
</span></span></code></pre></div><p>Just for fun, let&rsquo;s compile this in release mode and see how much overhead going
through <code>wasmer</code> adds.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo build --release --example basic-runtime
</span></span><span style=display:flex><span>$ time ../target/release/examples/basic-runtime ./example_program.wasm &gt; out.txt
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>../target/release/examples/basic-runtime ./example_program.wasm &gt; out.txt  1.09s user 2.79s system 99% cpu 3.879 total
</span></span><span style=display:flex><span>$ wc out.txt
</span></span><span style=display:flex><span> 180668  180668 1445344 out.txt
</span></span></code></pre></div><p>It looks like we wrote 1,445,344 bytes in 3.879 seconds for a throughput of
approximately 372.6 KB/sec. For comparison, the equivalent pure Rust program
(<code>fn main() { loop { println!("Polling"); } }</code>) printed 2,240,816 bytes in
4.225 for a throughput of 530.4 KB/sec.</p><p>That&rsquo;s pretty good!</p><h2 id=declaring-the-rest-of-the-platform-interface>Declaring the Rest of the Platform Interface
<a class=heading-link href=#declaring-the-rest-of-the-platform-interface><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Okay, so we know how to expose functions to the Wasm code to let it interact
with the rest of the environment. Now the next task is look at the problem
we&rsquo;re trying to solve, and provide functions which will help solve it.</p><p>While this section will be fairly specific to my use case (creating some sort
of programmable logic controller that people can upload code to), it should
be fairly easy to adapt to suit your application.</p><p>In our system, there are a handful of ways a program can interact with the
outside world:</p><ul><li>Log a message so it can be printed to some sort of debug window</li><li>Read an input from some memory-mapped IO</li><li>Write an output to some memory-mapped IO</li><li>Get the current time</li><li>Read and write named global variables</li></ul><p>The easiest way to declare which functions will be exposed by the runtime
(&ldquo;intrinsics&rdquo;) is with a normal C header file. This may seem a bit strange
for a Rust project, but just hear me out&mldr;</p><ol><li>A header file decouples the declaration of a function from its
implementation.</li><li>You can use <code>bindgen</code> to generate the corresponding Rust declarations</li><li>Using C header files enables people to write code for our application in
other languages (mainly C and C++)</li></ol><p>First off, it&rsquo;s a good idea to explain how we&rsquo;ll be handling fallible
operations. We&rsquo;ll be returning error codes, where anything other than
<code>WASM_SUCCESS</code> indicates an error.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// src/intrinsics.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The various error codes used by this library.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Every non-trivial function should return a wasm_result_t to indicate
</span></span></span><span style=display:flex><span><span style=color:#75715e> * whether it executed successfully.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>wasm_result_t</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The operation was successful.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WASM_SUCCESS <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// An unspecified error occurred.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WASM_GENERIC_ERROR <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Tried to access an input/output address which is out of bounds.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WASM_ADDRESS_OUT_OF_BOUNDS <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Tried to read an unknown variable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WASM_UNKNOWN_VARIABLE <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Tried to read/write a variable using the wrong type (e.g. you tried to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// write a boolean to an integer variable).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WASM_BAD_VARIABLE_TYPE <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Instead of our original <code>print()</code> function, let&rsquo;s create a fully-fledged logger.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// src/intrinsics.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The log levels used with `wasm_log()`.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> wasm_log_level {
</span></span><span style=display:flex><span>    LOG_ERROR <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    LOG_WARN <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    LOG_INFO <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    LOG_DEBUG <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    LOG_TRACE <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Log a message at the specified level, including information about the file
</span></span></span><span style=display:flex><span><span style=color:#75715e> * and line the message was logged from.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_log</span>(<span style=color:#66d9ef>int</span> level, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>file, <span style=color:#66d9ef>int</span> file_len, <span style=color:#66d9ef>int</span> line,
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>message, <span style=color:#66d9ef>int</span> message_len);
</span></span></code></pre></div><p>We should also make a helper macro so people don&rsquo;t constantly need to enter in
the filename and line number.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// src/intrinsics.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Convenience macro for logging a message.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define LOG(level, message) wasm_log(level, __FILE__, strlen(__FILE__), __LINE__, message, strlen(message))
</span></span></span></code></pre></div><p>Next we&rsquo;ll give users a way to read input and write output.</p><p>The runtime will make sure inputs are copied to a section of memory before
calling <code>poll()</code> and outputs will sit in another section of memory and be
synchronised with the real world after <code>poll()</code> completes. This is somewhat
similar to how <a href=https://en.wikipedia.org/wiki/Memory-mapped_I/O class=external-link target=_blank rel=noopener>Memory-mapped IO</a> works in embedded systems, or the
<a href=http://www.eng.utoledo.edu/~wevans/chap3_S.pdf class=external-link target=_blank rel=noopener>Process Image</a> on a PLC.</p><p>It&rsquo;s not uncommon to have batches of 16 digital outputs or read from a 24-bit
analogue sensor, so let&rsquo;s allow users to read/write in batches instead of one
bit/byte at a time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// src/intrinsics.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Read from an input from memory-mapped IO.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_read_input</span>(<span style=color:#66d9ef>uint32_t</span> address, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer, <span style=color:#66d9ef>int</span> buffer_len);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Write to an output using memory-mapped IO.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_write_output</span>(<span style=color:#66d9ef>uint32_t</span> address, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>data, <span style=color:#66d9ef>int</span> data_len);
</span></span></code></pre></div><p>Measuring the time should be fairly straightforward. The user doesn&rsquo;t
necessarily care about the actual time (plus <a href="https://www.youtube.com/watch?v=-5wpm-gesOY" class=external-link target=_blank rel=noopener>timezones are complicated!</a>)
so the we&rsquo;ll provide a way to get the number of seconds and nanoseconds since an
arbitrary point in time (probably when the runtime started) and they can use
that to see how much time has passed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// src/intrinsics.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Get a measurement of a monotonically nondecreasing clock.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The absolute numbers don&#39;t necessarily mean anything, the difference
</span></span></span><span style=display:flex><span><span style=color:#75715e> * between two measurements can be used to tell how much time has passed.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_current_time</span>(<span style=color:#66d9ef>uint64_t</span> <span style=color:#f92672>*</span>secs, <span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>nanos);
</span></span></code></pre></div><p>Next we need a way for different programs to communicate. For this, the
runtime will maintain a table of <em>&ldquo;global variables&rdquo;</em> which can either be
booleans, integers, or floating-point numbers (<code>bool</code>, <code>i32</code>, and <code>f64</code>
respectively).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// src/intrinsics.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Read a globally defined boolean variable.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Reading an unknown variable or trying to access a variable using the wrong
</span></span></span><span style=display:flex><span><span style=color:#75715e> * type will result in an error.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_variable_read_boolean</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>int</span> name_len, <span style=color:#66d9ef>bool</span> <span style=color:#f92672>*</span>value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_variable_read_double</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>int</span> name_len, <span style=color:#66d9ef>double</span> <span style=color:#f92672>*</span>value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_variable_read_int</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>int</span> name_len, <span style=color:#66d9ef>int32_t</span> <span style=color:#f92672>*</span>value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Write to a globally defined boolean variable.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * This may fail if the variable already exists and has a different type.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_variable_write_boolean</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>int</span> name_len, <span style=color:#66d9ef>bool</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_variable_write_double</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>int</span> name_len, <span style=color:#66d9ef>double</span> value);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>wasm_variable_write_int</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>name, <span style=color:#66d9ef>int</span> name_len, <span style=color:#66d9ef>int32_t</span> value);
</span></span></code></pre></div><p>Add in a couple <code>#include</code>s and a header guard, and we should now have a proper
definition of the functionality exposed by the runtime.</p><h2 id=dependency-injection>Dependency Injection
<a class=heading-link href=#dependency-injection><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>We now have a fairly solid interface that can be used by Wasm code, but it&rsquo;d
be really nice if we didn&rsquo;t hard-code the implementation for each function.
Luckily the <code>Ctx</code> passed to our functions by wasmer allows you to attach a
pointer to arbitrary data (<code>*mut c_void</code>) via <a href=https://docs.rs/wasmer-runtime/0.11.0/wasmer_runtime/struct.Ctx.html#structfield.data class=external-link target=_blank rel=noopener><code>Ctx::data</code></a>.</p><p>The normal way this is done is using <em>Dependency Injection</em>. Accept a generic
<code>Environment</code> object in the <code>poll()</code> method then set <code>Ctx::data</code> to point to
this <code>Environment</code> object while <code>poll()</code> is running.</p><p>First we&rsquo;re going to need an error type and a way to work with global variables
that may have different types.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Error</span> {
</span></span><span style=display:flex><span>    AddressOutOfBounds,
</span></span><span style=display:flex><span>    UnknownVariable,
</span></span><span style=display:flex><span>    BadVariableType,
</span></span><span style=display:flex><span>    Other(Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> std::error::Error<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Copy, Clone, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>    Bool(<span style=color:#66d9ef>bool</span>),
</span></span><span style=display:flex><span>    Integer(<span style=color:#66d9ef>i32</span>),
</span></span><span style=display:flex><span>    Float(<span style=color:#66d9ef>f64</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can define the <code>Environment</code> trait. It&rsquo;s essentially the Rust version of
our <code>intrinsics.h</code>, so its definition shouldn&rsquo;t be too surprising.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> Environment {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>elapsed</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Result<span style=color:#f92672>&lt;</span>Duration, Error<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_input</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>self,
</span></span><span style=display:flex><span>        address: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        buffer: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>u8</span>],
</span></span><span style=display:flex><span>    ) -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>write_output</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self,
</span></span><span style=display:flex><span>        address: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        buffer: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>],
</span></span><span style=display:flex><span>    ) -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>log</span>(<span style=color:#f92672>&amp;</span>self, record: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Record</span>) -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_variable</span>(<span style=color:#f92672>&amp;</span>self, name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Value, Error<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_variable</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, value: <span style=color:#a6e22e>Value</span>) -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The next thing we need to do is use the <code>data: *mut c_void</code> field on <code>Ctx</code> to
make sure each host function gets a reference to the current <code>Environment</code>.</p><p>This can be tricky because we&rsquo;re interacting with a lot of <code>unsafe</code>
code, in particular:</p><ul><li>We can&rsquo;t make the <code>poll()</code> function generic over any type <code>E: Environment</code>
because then when <code>Ctx::data</code> is read by our functions, they won&rsquo;t know
which type of <code>*mut E</code> to cast it to. The easiest way around this is to use
dynamic dispatch (i.e. <code>&amp;mut dyn Environment</code>)</li><li>You can&rsquo;t cast a fat pointer (<code>&amp;mut dyn Environment</code>) to a thin pointer
(<code>*mut c_void</code>) so we need a second level of indirection</li><li>The item pointed to by <code>Ctx::data</code> (our <code>Environment</code> object) is only
guaranteed to stay valid for the duration of <code>poll()</code> so we need to make sure
it gets cleared before returning</li><li>Code that we call may <code>panic!()</code> and we need to make sure <code>Ctx::data</code> is
cleared <em>no matter what</em>, otherwise we&rsquo;ll be leaving a dangling pointer behind
and future calls may try to use it</li></ul><p>To solve the first two problems we&rsquo;ll introduce an intermediate <code>State</code> object
which can be placed on the stack.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Temporary state passed to each host function via [`Ctx::data`].
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    env: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>dyn</span> Environment,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From here, the naive implementation for <code>poll()</code> would look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Program {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, env: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>dyn</span> Environment) -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state <span style=color:#f92672>=</span> State { env };
</span></span><span style=display:flex><span>        self.instance.context_mut().data <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> state <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> State <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self.instance.call(<span style=color:#e6db74>&#34;poll&#34;</span>, <span style=color:#f92672>&amp;</span>[])<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And yes, while it <em>does</em> correctly thread our <code>&amp;mut dyn Environment</code> through to
the instance-global context data, we&rsquo;ve completely ignored the last two points;
preventing our temporary <code>state</code> pointer from dangling, even if <code>wasmer</code>
panics.</p><p>The normal way to implement this is by putting <code>self.instance.call("poll", &[])</code>
inside a closure, then using a helper function to</p><ol><li>Do some setup</li><li>Call the closure from <code>std::panic::catch_unwind()</code></li><li>Do safety-critical cleanup, then</li><li>Resume panicking</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Program {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, env: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>dyn</span> Environment) -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.with_environment_context(env, <span style=color:#f92672>|</span>instance<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>            instance.call(<span style=color:#e6db74>&#34;poll&#34;</span>, <span style=color:#f92672>&amp;</span>[])<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            Ok(())
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>with_environment_context</span><span style=color:#f92672>&lt;</span>F, T<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self,
</span></span><span style=display:flex><span>        env: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> <span style=color:#66d9ef>dyn</span> Environment,
</span></span><span style=display:flex><span>        func: <span style=color:#a6e22e>F</span>,
</span></span><span style=display:flex><span>    ) -&gt; Result<span style=color:#f92672>&lt;</span>T, Error<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>        F: FnOnce(<span style=color:#f92672>&amp;</span>Instance) -&gt; Result<span style=color:#f92672>&lt;</span>T, Error<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> state <span style=color:#f92672>=</span> State { env };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> instance <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.instance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// point the data pointer at our temporary state.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        instance.context_mut().data <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> state <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> State<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> _;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// we can&#39;t use the old state variable any more (we&#39;d have aliased
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// pointers) so deliberately shadow it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>#[allow(unused_variables)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> state <span style=color:#f92672>=</span> ();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// execute the callback. We need to catch panics so we can clear the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// data pointer no matter what. Using AssertUnwindSafe is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// correct here because we&#39;ll continue panicking once the data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// pointer is cleared
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> got <span style=color:#f92672>=</span> panic::catch_unwind(AssertUnwindSafe(<span style=color:#f92672>||</span> func(instance)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// make sure the context data pointer is cleared. We don&#39;t need to drop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// anything because it was just a `&amp;mut State
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        instance.context_mut().data <span style=color:#f92672>=</span> ptr::null_mut();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> got {
</span></span><span style=display:flex><span>            Ok(value) <span style=color:#f92672>=&gt;</span> value,
</span></span><span style=display:flex><span>            Err(e) <span style=color:#f92672>=&gt;</span> panic::resume_unwind(e),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices info"><p>If you spot something here that looks odd, or you feel like my logic may be
unsound, I really want to hear about it! If you&rsquo;re not sure how to contact
me, you can create an issue against this blog&rsquo;s <a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/issues class=external-link target=_blank rel=noopener>issue tracker</a>.</p></div><p>We can now start creating our host functions.</p><p>First up, let&rsquo;s implement <code>wasm_current_time()</code>. The general strategy is:</p><ol><li>Get a pointer to our <code>State</code></li><li>Call the corresponding method on the <code>&amp;mut dyn Environment</code></li><li>Error out if something went wrong</li><li>Copy the result into Wasm memory</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>WASM_SUCCESS</span>: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_current_time</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    secs: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    nanos: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the data pointer should have been set by `with_environment_context()`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ctx.data.is_null() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> elapsed <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// the data pointer was set, we can assume it points to a valid State
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> state <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> <span style=color:#f92672>*</span>(ctx.data <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> State);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// and now we can call
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>match</span> state.env.elapsed() {
</span></span><span style=display:flex><span>            Ok(duration) <span style=color:#f92672>=&gt;</span> duration,
</span></span><span style=display:flex><span>            Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                log::error!(<span style=color:#e6db74>&#34;Unable to get the elapsed time: {}&#34;</span>, e);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> e.code();
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> memory <span style=color:#f92672>=</span> ctx.memory(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the verbose equivalent of a null check and `*secs = elapsed.as_secs()`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>match</span> secs.deref(memory) {
</span></span><span style=display:flex><span>        Some(cell) <span style=color:#f92672>=&gt;</span> cell.set(elapsed.as_secs()),
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> nanos.deref(memory) {
</span></span><span style=display:flex><span>        Some(cell) <span style=color:#f92672>=&gt;</span> cell.set(elapsed.subsec_nanos()),
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WASM_SUCCESS</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This part is up to you, but you <em>can</em> reduce a lot of the boilerplate around
this with a couple simple macros.</p><p>For example, instead of manually calling <code>deref()</code> on a <code>WasmPtr&lt;T></code> and
setting the <code>&amp;Cell&lt;T></code> we could define a <code>wasm_deref!()</code> macro like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> wasm_deref {
</span></span><span style=display:flex><span>    (with <span style=color:#75715e>$ctx</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#f92672>*</span> <span style=color:#75715e>$ptr</span>:<span style=color:#a6e22e>ident</span> <span style=color:#f92672>=</span> <span style=color:#75715e>$value</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> <span style=color:#75715e>$ptr</span>.deref(<span style=color:#75715e>$ctx</span>.memory(<span style=color:#ae81ff>0</span>)) {
</span></span><span style=display:flex><span>            Some(cell) <span style=color:#f92672>=&gt;</span> cell.set(<span style=color:#75715e>$value</span>),
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This reduces the bottom half of <code>wasm_current_time()</code> to</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_current_time</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    secs: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    nanos: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wasm_deref!(with ctx, <span style=color:#f92672>*</span>secs <span style=color:#f92672>=</span> elapsed.as_secs());
</span></span><span style=display:flex><span>    wasm_deref!(with ctx, <span style=color:#f92672>*</span>nanos <span style=color:#f92672>=</span> elapsed.subsec_nanos());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WASM_SUCCESS</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can replace the error handling around calling <code>env.elapsed()</code> with another
macro. While we&rsquo;re at it, we should also iterate over each <code>cause</code> in an error
and print a &ldquo;backtrace&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Error {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>code</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Error::AddressOutOfBounds <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>WASM_ADDRESS_OUT_OF_BOUNDS</span>,
</span></span><span style=display:flex><span>            Error::UnknownVariable <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>WASM_UNKNOWN_VARIABLE</span>,
</span></span><span style=display:flex><span>            Error::BadVariableType <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>WASM_BAD_VARIABLE_TYPE</span>,
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Convenience macro for executing a method using the [`Environment`] pointer
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// attached to [`Ctx::data`].
</span></span></span><span style=display:flex><span><span style=color:#e6db74>///
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// # Safety
</span></span></span><span style=display:flex><span><span style=color:#e6db74>///
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// This assumes the [`Ctx`] was set up correctly using
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// [`Program::with_environment_context()`].
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>macro_rules<span style=color:#f92672>!</span> try_with_env {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$ctx</span>:<span style=color:#a6e22e>expr</span>, <span style=color:#75715e>$method</span>:<span style=color:#a6e22e>ident</span> ( <span style=color:#75715e>$($arg</span>:<span style=color:#a6e22e>expr</span>),<span style=color:#f92672>*</span> ), <span style=color:#75715e>$failure_msg</span>:<span style=color:#a6e22e>expr</span>) <span style=color:#f92672>=&gt;</span> {{
</span></span><span style=display:flex><span>        <span style=color:#75715e>// the data pointer should have been set by `with_environment_context()`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#75715e>$ctx</span>.data.is_null() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> state <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> <span style=color:#f92672>*</span>(<span style=color:#75715e>$ctx</span>.data <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> State);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// call the method using the provided arguments
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>match</span> state.env.<span style=color:#75715e>$method</span>( <span style=color:#75715e>$(</span> <span style=color:#75715e>$arg</span> ),<span style=color:#f92672>*</span> ) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// happy path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Ok(value) <span style=color:#f92672>=&gt;</span> value,
</span></span><span style=display:flex><span>            Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// log the original error using the failure_msg
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                log::error!(concat!(<span style=color:#75715e>$failure_msg</span>, <span style=color:#e6db74>&#34;: {}&#34;</span>), e);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// then iterate through the causes and log those too
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> cause <span style=color:#f92672>=</span> std::error::Error::source(<span style=color:#f92672>&amp;</span>e);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(inner) <span style=color:#f92672>=</span> cause {
</span></span><span style=display:flex><span>                    log::error!(<span style=color:#e6db74>&#34;Caused by: {}&#34;</span>, inner);
</span></span><span style=display:flex><span>                    cause <span style=color:#f92672>=</span> inner.source();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// the operation failed, return the corresponding error code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> e.code();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With those two changes, our <code>wasm_current_time()</code> function now spends a lot more
time doing &ldquo;interesting&rdquo; things and isn&rsquo;t as cluttered by error-handling.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_current_time</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    secs: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    nanos: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u32</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> elapsed <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        try_with_env!(ctx, elapsed(), <span style=color:#e6db74>&#34;Unable to calculate the elapsed time&#34;</span>)
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wasm_deref!(with ctx, <span style=color:#f92672>*</span>secs <span style=color:#f92672>=</span> elapsed.as_secs());
</span></span><span style=display:flex><span>    wasm_deref!(with ctx, <span style=color:#f92672>*</span>nanos <span style=color:#f92672>=</span> elapsed.subsec_nanos());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WASM_SUCCESS</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices warning"><p>It may not necessarily be a good thing to introduce macros which try to
handle error cases and <code>unsafe</code> code automatically.</p><p>The best <code>unsafe</code> code is boring because another programmer can easily skim
through the function and check it for correctness because everything does
what it says on the tin. Burying error cases and <code>unsafe</code> by using macros or
helper functions may just make it easy to obfuscate otherwise obvious bugs.</p><p>The decision is very much up to the author&rsquo;s discretion.</p></div><p>Next we&rsquo;ll wire up the <code>wasm_log</code> function. The plan is to massage the provided
information into a form Rust&rsquo;s <a href=https://crates.io/crates/log class=external-link target=_blank rel=noopener><code>log</code></a> crate can handle, then let the
<code>Environment</code> pass the resulting <code>LogRecord</code> through to its logger.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_log</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    level: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    file: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    file_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    line: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    message: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    message_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Note: We can&#39;t directly accept the Level enum here because out-of-range
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// enum variants are UB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> level <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> level {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>LOG_ERROR</span> <span style=color:#f92672>=&gt;</span> Level::Error,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>LOG_WARN</span> <span style=color:#f92672>=&gt;</span> Level::Warn,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>LOG_INFO</span> <span style=color:#f92672>=&gt;</span> Level::Info,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>LOG_DEBUG</span> <span style=color:#f92672>=&gt;</span> Level::Debug,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>LOG_TRACE</span> <span style=color:#f92672>=&gt;</span> Level::Trace,
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> Level::Debug,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> filename <span style=color:#f92672>=</span> file.get_utf8_string(ctx.memory(<span style=color:#ae81ff>0</span>), file_len <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> message <span style=color:#f92672>=</span> message
</span></span><span style=display:flex><span>        .get_utf8_string(ctx.memory(<span style=color:#ae81ff>0</span>), message_len <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>)
</span></span><span style=display:flex><span>        .unwrap_or_default();
</span></span><span style=display:flex><span>gt
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        try_with_env!(
</span></span><span style=display:flex><span>            ctx,
</span></span><span style=display:flex><span>            <span style=color:#75715e>// unfortunately constructing a log record and using it needs to be
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// in a single statement because lifetimes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// https://users.rust-lang.org/t/using-format-args-and-log-builder/22695
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            log(<span style=color:#f92672>&amp;</span>Record::builder()
</span></span><span style=display:flex><span>                .level(level)
</span></span><span style=display:flex><span>                .file(filename.as_deref())
</span></span><span style=display:flex><span>                .line(Some(line <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u32</span>))
</span></span><span style=display:flex><span>                .args(format_args!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, message))
</span></span><span style=display:flex><span>                .build()),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Logging failed&#34;</span>
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WASM_SUCCESS</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Implementing the other host functions follows the same steps. After writing a
couple of these function &ldquo;trampolines&rdquo;, it goes from being a scary <code>unsafe</code>
task to a mechanical job of translating arguments and error values.</p><details><summary>A big wall of code that translates arguments and error values.</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> Error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(other: <span style=color:#a6e22e>Value</span>) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span>, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> other {
</span></span><span style=display:flex><span>            Value::Bool(b) <span style=color:#f92672>=&gt;</span> Ok(b),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> Err(Error::BadVariableType),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> Error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(other: <span style=color:#a6e22e>Value</span>) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span>, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> other {
</span></span><span style=display:flex><span>            Value::Integer(i) <span style=color:#f92672>=&gt;</span> Ok(i),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> Err(Error::BadVariableType),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>f64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> Error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(other: <span style=color:#a6e22e>Value</span>) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> other {
</span></span><span style=display:flex><span>            Value::Float(f) <span style=color:#f92672>=&gt;</span> Ok(f),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> Err(Error::BadVariableType),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Value {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(b: <span style=color:#66d9ef>bool</span>) -&gt; <span style=color:#a6e22e>Value</span> { Value::Bool(b) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Value {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(i: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#a6e22e>Value</span> { Value::Integer(i) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Value {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(d: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#a6e22e>Value</span> { Value::Float(d) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_read_input</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    address: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    buffer: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    buffer_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> temp_buffer <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>0</span>; buffer_len.try_into().unwrap()];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        try_with_env!(
</span></span><span style=display:flex><span>            ctx,
</span></span><span style=display:flex><span>            read_input(address.try_into().unwrap(), <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> temp_buffer[<span style=color:#f92672>..</span>]),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Unable to read the input&#34;</span>
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wasm_deref!(with ctx, <span style=color:#f92672>*</span>buffer <span style=color:#f92672>=</span> <span style=color:#66d9ef>for</span> byte <span style=color:#66d9ef>in</span> temp_buffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WASM_SUCCESS</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_write_output</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    address: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    data: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    data_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> buffer: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> data.deref(ctx.memory(<span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>0</span>, data_len.try_into().unwrap()) {
</span></span><span style=display:flex><span>            Some(slice) <span style=color:#f92672>=&gt;</span> slice.iter().map(<span style=color:#f92672>|</span>cell<span style=color:#f92672>|</span> cell.get()).collect(),
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        try_with_env!(
</span></span><span style=display:flex><span>            ctx,
</span></span><span style=display:flex><span>            write_output(address.try_into().unwrap(), <span style=color:#f92672>&amp;</span>buffer),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Unable to set outputs&#34;</span>
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WASM_SUCCESS</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>variable_get_and_map</span><span style=color:#f92672>&lt;</span>F, Q, T<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    name_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span>Q<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    map: <span style=color:#a6e22e>F</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>where</span>
</span></span><span style=display:flex><span>    F: FnOnce(T) -&gt; <span style=color:#a6e22e>Q</span>,
</span></span><span style=display:flex><span>    T: <span style=color:#a6e22e>TryFrom</span><span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    Q: <span style=color:#a6e22e>wasmer_runtime</span>::types::ValueType,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> name
</span></span><span style=display:flex><span>        .get_utf8_string(ctx.memory(<span style=color:#ae81ff>0</span>), name_len.try_into().unwrap())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Some(n) <span style=color:#f92672>=&gt;</span> n,
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> variable <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        try_with_env!(
</span></span><span style=display:flex><span>            ctx,
</span></span><span style=display:flex><span>            get_variable(name),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Unable to retrieve the variable&#34;</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> variable <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> T::try_from(variable) {
</span></span><span style=display:flex><span>        Ok(v) <span style=color:#f92672>=&gt;</span> v,
</span></span><span style=display:flex><span>        _ <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_BAD_VARIABLE_TYPE</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> value.deref(ctx.memory(<span style=color:#ae81ff>0</span>)) {
</span></span><span style=display:flex><span>        Some(cell) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            cell.set(map(variable));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>WASM_SUCCESS</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_variable_read_boolean</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    name_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    variable_get_and_map(
</span></span><span style=display:flex><span>        ctx,
</span></span><span style=display:flex><span>        name,
</span></span><span style=display:flex><span>        name_len,
</span></span><span style=display:flex><span>        value,
</span></span><span style=display:flex><span>        <span style=color:#f92672>|</span>b: <span style=color:#66d9ef>bool</span><span style=color:#f92672>|</span> <span style=color:#66d9ef>if</span> b { <span style=color:#ae81ff>1</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>0</span> },
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_variable_read_int</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    name_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    variable_get_and_map(ctx, name, name_len, value, <span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> i)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_variable_read_double</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    name_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    variable_get_and_map(ctx, name, name_len, value, <span style=color:#f92672>|</span>d<span style=color:#f92672>|</span> d)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_variable</span><span style=color:#f92672>&lt;</span>F, Q, T<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    name_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#a6e22e>Q</span>,
</span></span><span style=display:flex><span>    map: <span style=color:#a6e22e>F</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>where</span>
</span></span><span style=display:flex><span>    F: FnOnce(Q) -&gt; <span style=color:#a6e22e>T</span>,
</span></span><span style=display:flex><span>    T: Into<span style=color:#f92672>&lt;</span>Value<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> name
</span></span><span style=display:flex><span>        .get_utf8_string(ctx.memory(<span style=color:#ae81ff>0</span>), name_len.try_into().unwrap())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Some(n) <span style=color:#f92672>=&gt;</span> n,
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>WASM_GENERIC_ERROR</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> value <span style=color:#f92672>=</span> map(value).into();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        try_with_env!(
</span></span><span style=display:flex><span>            ctx,
</span></span><span style=display:flex><span>            set_variable(name, value),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Unable to set the variable&#34;</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WASM_SUCCESS</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_variable_write_boolean</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    name_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    set_variable(ctx, name, name_len, value, <span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_variable_write_int</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    name_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    set_variable(ctx, name, name_len, value, <span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wasm_variable_write_double</span>(
</span></span><span style=display:flex><span>    ctx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ctx,
</span></span><span style=display:flex><span>    name: <span style=color:#a6e22e>WasmPtr</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span>, Array<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    name_len: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    value: <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    set_variable(ctx, name, name_len, value, <span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> v)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details><h2 id=creating-our->Creating Our <em>&ldquo;Standard Library&rdquo;</em>
<a class=heading-link href=#creating-our-><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Technically we now have everything we need so users can write programs that run
on our motion controller, but manually writing <code>extern</code> blocks at the top of
every program is pretty clunky.</p><p>In most systems you&rsquo;ll have a <em>&ldquo;Standard Library&rdquo;</em> which provides bindings to
the host environment (typically the OS) and higher-level abstractions. Why
should our system be any different?</p><p>We&rsquo;ll start by creating a new crate for our standard library, imaginatively
called <code>wasm_std</code>, and add it to the current workspace.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cd ..
</span></span><span style=display:flex><span>$ cargo new --lib --name wasm_std std
</span></span><span style=display:flex><span>     Created library `wasm_std` package
</span></span></code></pre></div><div class="notices info"><p>I&rsquo;ve also moved <code>intrinsics.h</code> (declaring the host interface) to this
<code>std</code> crate because it&rsquo;s a more appropriate place.</p></div><p>Before we can throw <code>intrinsics.h</code> at <code>bindgen</code> we need to create type
definitions for the various integer types in <code>stdint.h</code>. Normally <code>bindgen</code>
would be able to use types from <code>std::os::raw</code>, but because we aren&rsquo;t using the
standard library we don&rsquo;t have access to them. Likewise we can&rsquo;t use the types
from <code>libc</code> because that would mean linking to <code>libc</code>, which isn&rsquo;t an option
either. See the <a href=https://github.com/rust-lang/rust-bindgen/issues/1583 class=external-link target=_blank rel=noopener>issue on GitHub</a> if you&rsquo;re interested.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// std/src/ctypes.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#e6db74>//! Re-exports of C types on a &#34;normal&#34; x86 computer. Normally you&#39;d use
</span></span></span><span style=display:flex><span><span style=color:#e6db74>//! `std::os::raw` or `libc`, but in our case that&#39;s not possible.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>//!
</span></span></span><span style=display:flex><span><span style=color:#e6db74>//! Most of these definitions are copied straight from `libc`&#39;s source code.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#![allow(bad_style, dead_code)]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/libc/unix/linux_like/linux/gnu/b64/x86_64/mod.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_char</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>i8</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>wchar_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/libc/unix/linux_like/linux/gnu/b64/x86_64/not_x32.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_long</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_ulong</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// src/libc/unix/mod.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_schar</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>i8</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_uchar</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_short</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>i16</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_ushort</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u16</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_int</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_uint</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_float</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>f32</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_double</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>f64</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_longlong</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>c_ulonglong</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>intmax_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>i64</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>uintmax_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>size_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ptrdiff_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>intptr_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>uintptr_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>usize</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ssize_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>isize</span>;
</span></span></code></pre></div><p>We can now generate declarations for <code>intrinsics.h</code>. This will
be analogous to <a href=https://doc.rust-lang.org/std/intrinsics/index.html class=external-link target=_blank rel=noopener><code>std::intrinsics</code></a> in Rust&rsquo;s standard library.</p><p>After a bit of trial and error, this incantation seemed to generate the output
we want without trying to add declarations for half of <code>libc</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cp ../intrinsics.h .
</span></span><span style=display:flex><span>$ bindgen intrinsics.h <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --whitelist-type &#39;wasm_.*&#39; \
</span></span><span style=display:flex><span>    --whitelist-function &#39;wasm_.*&#39; \
</span></span><span style=display:flex><span>    --output src/intrinsics.rs \
</span></span><span style=display:flex><span>    --use-core \
</span></span><span style=display:flex><span>    --ctypes-prefix crate::ctypes \
</span></span><span style=display:flex><span>     --raw-line &#39;#![allow(bad_style, dead_code)]&#39;
</span></span><span style=display:flex><span>$ tail src/intrinsics.rs
</span></span><span style=display:flex><span>extern &#34;C&#34; {
</span></span><span style=display:flex><span>    /// Write to a globally defined integer variable.
</span></span><span style=display:flex><span>    ///
</span></span><span style=display:flex><span>    /// This may fail if the variable already exists and has a different type.
</span></span><span style=display:flex><span>    pub fn wasm_variable_write_int(
</span></span><span style=display:flex><span>        name: *const ::std::os::raw::c_char,
</span></span><span style=display:flex><span>        name_len: ::std::os::raw::c_int,
</span></span><span style=display:flex><span>        value: i32,
</span></span><span style=display:flex><span>    ) -&gt; wasm_result_t;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our <code>lib.rs</code> needs to be updated to use <code>intrinsics</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// std/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#e6db74>//! The standard library, providing host bindings and abstractions.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// we are the standard library.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#![no_std]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>mod</span> intrinsics;
</span></span></code></pre></div><p>While it&rsquo;s still quite small at the moment, as we gain more experience using
this system we&rsquo;ll be able to move commonly-used elements into the standard
library to provide a more <em>batteries included</em> feel.</p><div class="notices tip"><p>Seeing as the end goal is for users to write programs for our controller in
any language, not just Rust, this may eventually require tools like
[<em>Interface Types</em>][interface-types].</p></div><p>Now we have a standard library we can rewrite our previous <code>example-program.rs</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cd ../examples/wasm-programs
</span></span><span style=display:flex><span>$ rm example-program.rs
</span></span><span style=display:flex><span>$ cargo new example-program
</span></span><span style=display:flex><span>$ cd example-program
</span></span></code></pre></div><p>We need to add our standard library as a dependency.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo add ../../../std
</span></span><span style=display:flex><span>    Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
</span></span><span style=display:flex><span>      Adding wasm-std (unknown version) to dependencies
</span></span></code></pre></div><p>Because this crate is being compiled to Wasm we&rsquo;ll need to make sure it is
compiled using the <code>cdylib</code> crate type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#75715e># examples/wasm-programs/example-program/Cargo.toml</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>package</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;example-program&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.1.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>authors</span> = [<span style=color:#e6db74>&#34;Michael Bryan &lt;michaelfbryan@gmail.com&gt;&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>edition</span> = <span style=color:#e6db74>&#34;2018&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>lib</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>crate-type</span> = [<span style=color:#e6db74>&#34;cdylib&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>dependencies</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>wasm-std</span> = { <span style=color:#a6e22e>path</span> = <span style=color:#e6db74>&#34;../../../../std/&#34;</span> }
</span></span></code></pre></div><p>At some point we&rsquo;ll want to create a nice <code>println!()</code> macro instead of
invoking the <code>wasm_log()</code> intrinsic directly, but for now here&rsquo;s the
equivalent of our original program.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// examples/wasm-programs/example-program/src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#![no_std]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> wasm_std::intrinsics::{
</span></span><span style=display:flex><span>    self, wasm_log_level_LOG_INFO <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>LOG_INFO</span>,
</span></span><span style=display:flex><span>    wasm_result_t_WASM_SUCCESS <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>WASM_SUCCESS</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> file <span style=color:#f92672>=</span> file!();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> msg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Polling</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ret <span style=color:#f92672>=</span> intrinsics::wasm_log(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>LOG_INFO</span>,
</span></span><span style=display:flex><span>            file.as_ptr() <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _,
</span></span><span style=display:flex><span>            file.len() <span style=color:#66d9ef>as</span> _,
</span></span><span style=display:flex><span>            line!() <span style=color:#66d9ef>as</span> _,
</span></span><span style=display:flex><span>            msg.as_ptr() <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> _,
</span></span><span style=display:flex><span>            msg.len() <span style=color:#66d9ef>as</span> _,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(ret, <span style=color:#66d9ef>WASM_SUCCESS</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We should now be able to build this crate.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo build
</span></span><span style=display:flex><span>   Compiling wasm-std v0.1.0 (/home/michael/Documents/wasm/std)
</span></span><span style=display:flex><span>   Compiling example-program v0.1.0 (/home/michael/Documents/wasm/examples/wasm-programs/example-program)
</span></span><span style=display:flex><span>error: `#[panic_handler]` function required, but not found
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>error: aborting due to previous error
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>error: could not compile `example-program`.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>To learn more, run the command again with --verbose.
</span></span></code></pre></div><p>Oops! Looks like using <code>assert_eq!()</code> requires code for handling panics.</p><p>To make sure normal users don&rsquo;t need to define a <code>#[panic_handler]</code> for every
program, we&rsquo;ll implement it in our standard library. We can just use Wasm&rsquo;s
<code>unreachable</code> command for now. This will trigger the corresponding &ldquo;trap&rdquo; on the
Wasm virtual machine and immediately stop execution.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// std/src/sys.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#![cfg(all(not(test), target_arch = </span><span style=color:#e6db74>&#34;wasm32&#34;</span><span style=color:#75715e>))]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> core::panic::PanicInfo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[panic_handler]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>panic_handler</span>(info: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>PanicInfo</span>) -&gt; <span style=color:#f92672>!</span> {
</span></span><span style=display:flex><span>    core::arch::wasm32::unreachable()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can successfully compile and run our program.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo build --target wasm32-unknown-unknown
</span></span><span style=display:flex><span>   Compiling wasm-std v0.1.0 (/home/michael/Documents/wasm/std)
</span></span><span style=display:flex><span>   Compiling example-program v0.1.0 (/home/michael/Documents/wasm/examples/wasm-programs/example-program)
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.21s
</span></span><span style=display:flex><span>$ ls target/wasm32-unknown-unknown/debug
</span></span><span style=display:flex><span>build  deps  example_program.d  example_program.wasm  examples  incremental
</span></span><span style=display:flex><span>$ cd ../../..
</span></span><span style=display:flex><span>$ cargo run --example basic-runtime -- examples/wasm-programs/example-program/target/wasm32-unknown-unknown/debug/example_program.wasm
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>^C
</span></span></code></pre></div><p>Oh, we forgot to add <code>env_logger</code> as a dev-dependency and initialize it in the <code>basic-runtime.rs</code> example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/wasm/examples/basic-runtime.rs b/wasm/examples/basic-runtime.rs
</span></span><span style=display:flex><span>index de2017d..586d54d 100644
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/wasm/examples/basic-runtime.rs
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/wasm/examples/basic-runtime.rs
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -2,6 +2,8 @@ use wasm::{InMemory, Program};
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> use std::env;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span></span><span style=display:flex><span><span style=color:#a6e22e>+    env_logger::init();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>     let wasm_file = match env::args().skip(1).next() {
</span></span><span style=display:flex><span>         Some(filename) =&gt; filename,
</span></span><span style=display:flex><span>         None =&gt; panic!(&#34;Usage: basic-runtime &lt;wasm-file&gt;&#34;),
</span></span></code></pre></div><p>Now it should work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>RUST_LOG=info cargo run --example basic-runtime -- examples/wasm-programs/example-program/target/wasm32-unknown-unknown/debug/example_program.wasm
</span></span><span style=display:flex><span>   Compiling wasm v0.1.0 (/home/michael/Documents/wasm)
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 1.14s
</span></span><span style=display:flex><span>     Running `/home/michael/Documents/wasm/target/debug/examples/basic-runtime examples/wasm-programs/example-program/target/wasm32-unknown-unknown/debug/example_program.wasm`
</span></span><span style=display:flex><span>[2019-12-11T10:12:25Z INFO ] Polling
</span></span><span style=display:flex><span>[2019-12-11T10:12:25Z INFO ] Polling
</span></span><span style=display:flex><span>[2019-12-11T10:12:25Z INFO ] Polling
</span></span><span style=display:flex><span>[2019-12-11T10:12:25Z INFO ] Polling
</span></span><span style=display:flex><span>[2019-12-11T10:12:25Z INFO ] Polling
</span></span><span style=display:flex><span>[2019-12-11T10:12:25Z INFO ] Polling
</span></span><span style=display:flex><span>^C
</span></span></code></pre></div><p>Huzzah!</p><h2 id=testing-everything>Testing Everything
<a class=heading-link href=#testing-everything><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>So now we can run an example program, but needing to manually set up a crate
and compile it every time isn&rsquo;t the best method of testing. It&rsquo;d be better if
our test suite could automatically compile and run a collection of programs,
feeding it pre-defined inputs, and making sure it behaved as expected.</p><p>Rust&rsquo;s <a href=https://rust-lang.github.io/rustc-guide/compiletest.html class=external-link target=_blank rel=noopener>compiletest</a> is a really good example of this in action. At this
point it&rsquo;s worth taking a peek at <code>rustc</code>&rsquo;s test suite to see how similar
projects are tested. Hopefully we can use it as inspiration.</p><p>When testing the compiler&rsquo;s error message the compiler&rsquo;s test suite will contain
a <code>*.rs</code> file containing code which annotates offending lines (e.g. using a
comment like <code>//~ ERROR: ...</code>) and a <code>*.stderr</code> file containing the exact output
from STDOUT.</p><p>A simple example of this is
<a href=https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src/test/ui/empty/empty-linkname.rs class=external-link target=_blank rel=noopener>rust/src/test/ui/empty/empty-linkname.rs</a> for detecting
when the <code>name</code> parameter passed to <code>#[link]</code> is empty.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[link(name = </span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#75715e>)]</span> <span style=color:#75715e>//~ ERROR: given with empty name
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {}
</span></span></code></pre></div><p>The contents of <a href=https://github.com/rust-lang/rust/blob/master/src/test/ui/empty/empty-linkname.stderr class=external-link target=_blank rel=noopener>empty-linkname.stderr</a> looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>error[E0454]: `#[link(name = &#34;&#34;)]` given with empty name
</span></span><span style=display:flex><span>  --&gt; $DIR/empty-linkname.rs:1:1
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>LL | #[link(name = &#34;&#34;)]
</span></span><span style=display:flex><span>   | ^^^^^^^^^^^^^^^^^^ empty name given
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error: aborting due to previous error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>For more information about this error, try `rustc --explain E0454`.
</span></span></code></pre></div><p>We can take a fairly similar approach when designing a test suite for the
runtime. Tests will consist of two files, some source code (written in Rust) and
a file containing some representation of the expected output.</p><p>The main difference between our runtime&rsquo;s tests and <code>rustc</code>&rsquo;s UI tests is
that we&rsquo;ll need to incorporate a time element into the expected output. The
output is also less tangible, <code>rustc</code>&rsquo;s error messages are just text written to
STDERR compared to the array of binary that our runtime uses for outputs.</p><p>It&rsquo;s also easy for <code>rustc</code>&rsquo;s test suite to compile a single <code>*.rs</code> file and
inspect the output, it&rsquo;s something you could concievably implement using a
bash script. On the other hand, our compilation process is non-trivial, and
the requirement for inspecting changing inputs over time requires us to
instrument the runtime to insert checks for expected behaviour after every
call to <code>Program::poll()</code>.</p><p>Based on our previous experimentation, let&rsquo;s write down a simple testing
procedure:</p><ol><li>Write a file containing some program that uses our standard library and
does something interesting</li><li>Create a new crate in a temporary directory (e.g. <code>/tmp.123/</code>)</li><li>Make sure that crate depends on our standard library</li><li>Copy the file from step 1 to <code>lib.rs</code> in the temporary crate</li><li>Compile it</li><li>Find the <code>*.wasm</code> file under
<code>/tmp.123/target/wasm32-unknown-unknown/debug/</code> and read it into memory</li><li>Use <code>Program::load()</code> to instantiate that Wasm module</li><li>Continually <code>poll()</code> the program setting up inputs according to some
pre-defined <em>Recipe</em> and make sure outputs change as expected</li></ol><p>This may end up being a little complex so let&rsquo;s create a <code>wasm-test</code> helper
crate and add it to our workspace.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo new --lib wasm-test
</span></span></code></pre></div><p>We&rsquo;ll also be needing a couple dependencies.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo add log tempfile serde serde_derive serde_json anyhow ../wasm
</span></span><span style=display:flex><span>    Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
</span></span><span style=display:flex><span>      Adding log v0.4.8 to dependencies
</span></span><span style=display:flex><span>      Adding tempfile v3.1.0 to dependencies
</span></span><span style=display:flex><span>      Adding serde v1.0.103 to dependencies
</span></span><span style=display:flex><span>      Adding serde_derive v1.0.103 to dependencies
</span></span><span style=display:flex><span>      Adding serde_json v1.0.44 to dependencies
</span></span><span style=display:flex><span>      Adding anyhow v1.0.25 to dependencies
</span></span><span style=display:flex><span>      Adding wasm (unknown version) to dependencies
</span></span></code></pre></div><p>Looking back at steps 2 and 3, when creating our temporary crate we&rsquo;ll need to
make sure the <code>Cargo.toml</code> is set up correctly. There are a lot of advanced
templating libraries out there, but for our purposes <code>string.replace()</code>-style
&ldquo;templates&rdquo; should be more than sufficient.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/compile.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>CARGO_TOML_TEMPLATE</span>: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>r</span><span style=color:#e6db74>#&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>[package]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>name = &#34;$TEST_NAME&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>version = &#34;0.1.0&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>authors = [&#34;Michael Bryan &lt;michaelfbryan@gmail.com&gt;&#34;]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>edition = &#34;2018&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>[dependencies]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>wasm-std = { path = &#34;$STD_PATH&#34; }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>[lib]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>path = &#34;lib.rs&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>crate-type = [&#34;cdylib&#34;]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;#</span>;
</span></span></code></pre></div><p>The other compilation-related tasks are fairly straightforward to automate
using by just shelling out to <code>std::process::Command</code>. We can develop better
tooling in time, but this crude implementation should suffice for now.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/compile.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> anyhow::{Error, Context};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::{fs, path::Path};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> tempfile::TempDir;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compile_to_wasm</span>(
</span></span><span style=display:flex><span>    name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>    src: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>    target_dir: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>,
</span></span><span style=display:flex><span>    std_manifest_dir: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Path</span>,
</span></span><span style=display:flex><span>) -&gt; Result<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// first we&#39;ll need a directory for our crate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> dir <span style=color:#f92672>=</span> TempDir::new().context(<span style=color:#e6db74>&#34;Unable to create a temporary dir&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// then create a Cargo.toml file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> std_manifest_dir <span style=color:#f92672>=</span> std_manifest_dir.display().to_string();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cargo_toml <span style=color:#f92672>=</span> <span style=color:#66d9ef>CARGO_TOML_TEMPLATE</span>
</span></span><span style=display:flex><span>        .replace(<span style=color:#e6db74>&#34;$TEST_NAME&#34;</span>, name)
</span></span><span style=display:flex><span>        .replace(<span style=color:#e6db74>&#34;$STD_PATH&#34;</span>, <span style=color:#f92672>&amp;</span>std_manifest_dir);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> cargo_toml_path <span style=color:#f92672>=</span> dir.path().join(<span style=color:#e6db74>&#34;Cargo.toml&#34;</span>);
</span></span><span style=display:flex><span>    fs::write(<span style=color:#f92672>&amp;</span>cargo_toml_path, cargo_toml)
</span></span><span style=display:flex><span>        .context(<span style=color:#e6db74>&#34;Couldn&#39;t write Cargo.toml&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy our source code across
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    fs::write(dir.path().join(<span style=color:#e6db74>&#34;lib.rs&#34;</span>), src)
</span></span><span style=display:flex><span>        .context(<span style=color:#e6db74>&#34;Couldn&#39;t write lib.rs&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// compile to wasm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> output <span style=color:#f92672>=</span> Command::new(<span style=color:#e6db74>&#34;cargo&#34;</span>)
</span></span><span style=display:flex><span>        .arg(<span style=color:#e6db74>&#34;build&#34;</span>)
</span></span><span style=display:flex><span>        .arg(<span style=color:#e6db74>&#34;--manifest-path&#34;</span>)
</span></span><span style=display:flex><span>        .arg(<span style=color:#f92672>&amp;</span>cargo_toml_path)
</span></span><span style=display:flex><span>        .arg(<span style=color:#e6db74>&#34;--target-dir&#34;</span>)
</span></span><span style=display:flex><span>        .arg(<span style=color:#f92672>&amp;</span>target_dir)
</span></span><span style=display:flex><span>        .arg(<span style=color:#e6db74>&#34;--target&#34;</span>)
</span></span><span style=display:flex><span>        .arg(<span style=color:#e6db74>&#34;wasm32-unknown-unknown&#34;</span>)
</span></span><span style=display:flex><span>        .arg(<span style=color:#e6db74>&#34;--offline&#34;</span>)
</span></span><span style=display:flex><span>        .status()
</span></span><span style=display:flex><span>        .context(<span style=color:#e6db74>&#34;Unable to start cargo&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    anyhow::ensure!(output.success(), <span style=color:#e6db74>&#34;Compilation failed&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// look for the Wasm file using a hard-coded path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> blob <span style=color:#f92672>=</span> target_dir
</span></span><span style=display:flex><span>        .join(<span style=color:#e6db74>&#34;wasm32-unknown-unknown&#34;</span>)
</span></span><span style=display:flex><span>        .join(<span style=color:#e6db74>&#34;debug&#34;</span>)
</span></span><span style=display:flex><span>        .join(name)
</span></span><span style=display:flex><span>        .with_extension(<span style=color:#e6db74>&#34;wasm&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fs::read(<span style=color:#f92672>&amp;</span>blob)
</span></span><span style=display:flex><span>        .with_context(<span style=color:#f92672>||</span> format!(<span style=color:#e6db74>&#34;Unable to read </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>{}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>, blob.display()))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To avoid having to always provide the <code>target_dir</code> and <code>std_manifest_dir</code>
parameters every time we can wrap them up inside some sort of <code>Compiler</code> struct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/compile.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Compiler</span> {
</span></span><span style=display:flex><span>    std_manifest_dir: <span style=color:#a6e22e>PathBuf</span>,
</span></span><span style=display:flex><span>    target_dir: <span style=color:#a6e22e>PathBuf</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From here, instantiating a Wasm program can be implemented as a method on
<code>Compiler</code> which just calls <code>compile_to_wasm()</code> and <code>Program::load()</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/compile.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> wasm::Program;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Compiler {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>instantiate</span>(<span style=color:#f92672>&amp;</span>self, name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, src: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Program, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> wasm <span style=color:#f92672>=</span> compile_to_wasm(
</span></span><span style=display:flex><span>            name,
</span></span><span style=display:flex><span>            src,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;</span>self.target_dir,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;</span>self.std_manifest_dir,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Program::load(<span style=color:#f92672>&amp;</span>wasm)
</span></span><span style=display:flex><span>            .map_err(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> anyhow::format_err!(<span style=color:#e6db74>&#34;Wasm loading failed: {}&#34;</span>, e))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we need some sort of <code>TestCase</code> which can be loaded from disk. In this
case <code>some-program.rs</code> will be the code being tested and <code>some-program.json</code>
will contain a <code>Recipe</code> dictating the expected behaviour.</p><p>We&rsquo;ll need to derive <code>Serialize</code> and <code>Deserialize</code> so the <code>Recipe</code> can be loaded
from JSON.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/test_case.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> serde_derive::{Deserialize, Serialize};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// A single test case.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TestCase</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> name: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> src: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> recipe: <span style=color:#a6e22e>Recipe</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// A series of snapshots containing inputs and expected outputs for the test
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// program.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Recipe</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> passes: Vec<span style=color:#f92672>&lt;</span>Pass<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// The inputs and expected outputs for a single call to [`Program::poll()`].
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Pass</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[serde(with = </span><span style=color:#e6db74>&#34;humantime_serde&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> elapsed: <span style=color:#a6e22e>Duration</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> inputs: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> expected_outputs: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[serde(default)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> expected_log_messages: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ll also need constructors which can load a <code>TestCase</code> from a <code>*.rs</code> and
<code>*.json</code> file on disk.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/test_case.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> anyhow::{Context, Error};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TestCase {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span><span style=color:#f92672>&lt;</span>P, Q<span style=color:#f92672>&gt;</span>(src_file: <span style=color:#a6e22e>P</span>, recipe_file: <span style=color:#a6e22e>Q</span>) -&gt; Result<span style=color:#f92672>&lt;</span>TestCase, Error<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>        P: AsRef<span style=color:#f92672>&lt;</span>Path<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        Q: AsRef<span style=color:#f92672>&lt;</span>Path<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> src_file <span style=color:#f92672>=</span> src_file.as_ref();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            src_file
</span></span><span style=display:flex><span>                .file_name()
</span></span><span style=display:flex><span>                .and_then(<span style=color:#f92672>|</span>n<span style=color:#f92672>|</span> n.to_str())
</span></span><span style=display:flex><span>                .ok_or_else(<span style=color:#f92672>||</span> {
</span></span><span style=display:flex><span>                    anyhow::format_err!(<span style=color:#e6db74>&#34;Unable to determine the filename&#34;</span>)
</span></span><span style=display:flex><span>                })<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> fs::read_to_string(src_file)
</span></span><span style=display:flex><span>            .context(<span style=color:#e6db74>&#34;Couldn&#39;t read the source file&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> recipe <span style=color:#f92672>=</span> fs::read_to_string(recipe_file)
</span></span><span style=display:flex><span>            .context(<span style=color:#e6db74>&#34;Couldn&#39;t read the recipe file&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TestCase::parse(name, src, recipe)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse</span><span style=color:#f92672>&lt;</span>N, S, R<span style=color:#f92672>&gt;</span>(name: <span style=color:#a6e22e>N</span>, src: <span style=color:#a6e22e>S</span>, recipe: <span style=color:#a6e22e>R</span>) -&gt; Result<span style=color:#f92672>&lt;</span>TestCase, Error<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>        N: Into<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        S: Into<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        R: AsRef<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> name <span style=color:#f92672>=</span> name.into();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> src.into();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> recipe <span style=color:#f92672>=</span> serde_json::from_str(recipe.as_ref())
</span></span><span style=display:flex><span>            .context(<span style=color:#e6db74>&#34;Recipe parsing failed&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(TestCase { name, src, recipe })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We also need an implementation of <code>Environment</code> for testing purposes. This is
the <em>&ldquo;instrumenting&rdquo;</em> part mentioned earlier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/environment.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> log::Level;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Default, Clone, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TestEnvironment</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> elapsed: <span style=color:#a6e22e>Duration</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> inputs: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> outputs: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> log_messages: Vec<span style=color:#f92672>&lt;</span>(Level, String)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> variables: <span style=color:#a6e22e>HashMap</span><span style=color:#f92672>&lt;</span>String, Value<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Implementing the <code>Environment</code> trait is more tedious than anything else.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/environment.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> wasm::{Environment, Error <span style=color:#66d9ef>as</span> WasmError};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> wasm::Environment <span style=color:#66d9ef>for</span> TestEnvironment {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>elapsed</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Result<span style=color:#f92672>&lt;</span>Duration, WasmError<span style=color:#f92672>&gt;</span> { Ok(self.elapsed) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>read_input</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>self,
</span></span><span style=display:flex><span>        address: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        buffer: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>u8</span>],
</span></span><span style=display:flex><span>    ) -&gt; Result<span style=color:#f92672>&lt;</span>(), WasmError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>            .inputs
</span></span><span style=display:flex><span>            .get(address<span style=color:#f92672>..</span>address <span style=color:#f92672>+</span> buffer.len())
</span></span><span style=display:flex><span>            .ok_or(WasmError::AddressOutOfBounds)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        buffer.copy_from_slice(src);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>write_output</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self,
</span></span><span style=display:flex><span>        address: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>        buffer: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>],
</span></span><span style=display:flex><span>    ) -&gt; Result<span style=color:#f92672>&lt;</span>(), WasmError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> dest <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>            .outputs
</span></span><span style=display:flex><span>            .get_mut(address<span style=color:#f92672>..</span>address <span style=color:#f92672>+</span> buffer.len())
</span></span><span style=display:flex><span>            .ok_or(WasmError::AddressOutOfBounds)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        dest.copy_from_slice(buffer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>log</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, record: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Record</span><span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>(), WasmError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.log_messages
</span></span><span style=display:flex><span>            .push((record.level(), record.args().to_string()));
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_variable</span>(<span style=color:#f92672>&amp;</span>self, name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Value, WasmError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.variables
</span></span><span style=display:flex><span>            .get(name)
</span></span><span style=display:flex><span>            .copied()
</span></span><span style=display:flex><span>            .ok_or(WasmError::UnknownVariable)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_variable</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self,
</span></span><span style=display:flex><span>        name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>        value: <span style=color:#a6e22e>Value</span>,
</span></span><span style=display:flex><span>    ) -&gt; Result<span style=color:#f92672>&lt;</span>(), WasmError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>use</span> std::collections::hash_map::Entry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self.variables.entry(name.to_string()) {
</span></span><span style=display:flex><span>            Entry::Vacant(vacant) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                vacant.insert(value);
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            Entry::Occupied(<span style=color:#66d9ef>mut</span> occupied) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> occupied.get().kind() <span style=color:#f92672>==</span> value.kind() {
</span></span><span style=display:flex><span>                    occupied.insert(value);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> Err(WasmError::BadVariableType);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We should also add some code for doing the setup and comparison steps when
polling.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/environment.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::Pass;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> anyhow::Error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TestEnvironment {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>setup</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, pass: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Pass</span>) {
</span></span><span style=display:flex><span>        self.elapsed <span style=color:#f92672>=</span> pass.elapsed;
</span></span><span style=display:flex><span>        self.load_inputs(<span style=color:#f92672>&amp;</span>pass.inputs);
</span></span><span style=display:flex><span>        self.outputs.clear();
</span></span><span style=display:flex><span>        self.outputs
</span></span><span style=display:flex><span>            .extend(std::iter::repeat(<span style=color:#ae81ff>0</span>).take(pass.expected_outputs.len()));
</span></span><span style=display:flex><span>        self.log_messages.clear();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load_inputs</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, inputs: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>]) {
</span></span><span style=display:flex><span>        self.inputs.clear();
</span></span><span style=display:flex><span>        self.inputs.extend(inputs);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compare</span>(<span style=color:#f92672>&amp;</span>self, pass: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Pass</span>) -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.outputs <span style=color:#f92672>!=</span> pass.expected_outputs {
</span></span><span style=display:flex><span>            anyhow::bail!(<span style=color:#e6db74>&#34;{:?} != {:?}&#34;</span>, self.outputs, pass.expected_outputs);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// create a temporary set containing all log messages
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> log_messages: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>            .log_messages
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(_, msg)<span style=color:#f92672>|</span> msg.clone())
</span></span><span style=display:flex><span>            .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> msg <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>pass.expected_log_messages {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>match</span> log_messages.iter().position(<span style=color:#f92672>|</span>logged<span style=color:#f92672>|</span> logged.contains(msg)) {
</span></span><span style=display:flex><span>                Some(position) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// we&#39;ve found the message, remove it from the list of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// candidates and go to the next one.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    log_messages.remove(position);
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>                None <span style=color:#f92672>=&gt;</span> anyhow::bail!(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;Unable to find log message </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>{}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74> in {:?}&#34;</span>,
</span></span><span style=display:flex><span>                    msg,
</span></span><span style=display:flex><span>                    self.log_messages
</span></span><span style=display:flex><span>                ),
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>log_messages.is_empty() {
</span></span><span style=display:flex><span>            anyhow::bail!(<span style=color:#e6db74>&#34;Unexpected log messages: {:?}&#34;</span>, log_messages);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our <code>wasm-test</code> crate can now compile a Rust program to Wasm and link it to our
standard library, instantiate the Wasm module, load a pre-defined test recipe,
and create a test <code>Environment</code>.</p><p>Now we just need a way to execute a particular test case and the <code>wasm-test</code>
crate will be complete.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// wasm-test/src/lib.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> compile;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> environment;
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> test_case;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>use</span> compile::Compiler;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>use</span> environment::TestEnvironment;
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>use</span> test_case::{Pass, Recipe, TestCase};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> anyhow::{Context, Error};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run_test_case</span>(
</span></span><span style=display:flex><span>    compiler: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Compiler</span>,
</span></span><span style=display:flex><span>    test_case: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>TestCase</span>,
</span></span><span style=display:flex><span>) -&gt; Result<span style=color:#f92672>&lt;</span>(), Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> wasm <span style=color:#f92672>=</span> compiler
</span></span><span style=display:flex><span>        .instantiate(<span style=color:#f92672>&amp;</span>test_case.name, <span style=color:#f92672>&amp;</span>test_case.src)
</span></span><span style=display:flex><span>        .context(<span style=color:#e6db74>&#34;Unable to load the Wasm module&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> env <span style=color:#f92672>=</span> TestEnvironment::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> pass <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>test_case.recipe.passes {
</span></span><span style=display:flex><span>        env.setup(pass);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        wasm.poll(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> env)
</span></span><span style=display:flex><span>            .map_err(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> Error::msg(e.to_string()))
</span></span><span style=display:flex><span>            .context(<span style=color:#e6db74>&#34;Polling failed&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        env.compare(pass).context(<span style=color:#e6db74>&#34;Output comparison failed&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now the <code>wasm-test</code> crate is up and running we can go back to the <code>wasm</code> crate&rsquo;s
integration tests.</p><p>I&rsquo;ve copied the <code>example-program.rs</code> from the last section into the
<code>tests/data/</code> directory and written up a simple <code>example_program.json</code> file
which will make sure it prints <code>"Polling"</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#75715e>// tests/data/example_program.json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;passes&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;elapsed&#34;</span>: <span style=color:#e6db74>&#34;50ms&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;inputs&#34;</span>: [],
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;expected_outputs&#34;</span>: [],
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;expected_log_messages&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Polling&#34;</span>
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To make sure we&rsquo;ve wired up the <code>wasm_write_output()</code> function correctly,
there&rsquo;s also a <code>set_outputs.rs</code> test program.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// tests/data/set_outputs.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#![no_std]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> wasm_std::intrinsics::{
</span></span><span style=display:flex><span>    self, wasm_result_t_WASM_SUCCESS <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>WASM_SUCCESS</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>ADDRESS</span>: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[no_mangle]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> payload <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ret <span style=color:#f92672>=</span> intrinsics::wasm_write_output(
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>ADDRESS</span>,
</span></span><span style=display:flex><span>            payload.as_ptr(),
</span></span><span style=display:flex><span>            payload.len() <span style=color:#66d9ef>as</span> _,
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        assert_eq!(ret, <span style=color:#66d9ef>WASM_SUCCESS</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And its accompanying <code>*.json</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#75715e>// tests/data/set_outputs.json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;passes&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;elapsed&#34;</span>: <span style=color:#e6db74>&#34;50ms&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;inputs&#34;</span>: [],
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;expected_outputs&#34;</span>: [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we just need to make sure the test programs get run and behave as expected.</p><p>For this we&rsquo;ll create the aptly-named <code>behaviour_tests.rs</code> integration test
under <code>tests/</code>.</p><p>Thanks to the work we did earlier, loading and running an integration test
becomes really easy.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// tests/behaviour_tests.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> anyhow::Context;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> wasm_test::{TestCase, Compiler};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_outputs</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> env_logger::try_init();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> include_str!(<span style=color:#e6db74>&#34;data/set_outputs.rs&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> recipe <span style=color:#f92672>=</span> include_str!(<span style=color:#e6db74>&#34;data/set_outputs.json&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tc <span style=color:#f92672>=</span> TestCase::parse(set_outputs, src, recipe)
</span></span><span style=display:flex><span>        .context(<span style=color:#e6db74>&#34;Unable to load the test case&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> compiler <span style=color:#f92672>=</span> Compiler::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wasm_test::run_test_case(<span style=color:#f92672>&amp;</span>compiler, <span style=color:#f92672>&amp;</span>tc).unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we want to make more tests, one way would be to copy the <code>set_outputs</code>
function and replace every instance of <code>"set_outputs"</code> with the name of the
tests.</p><p>That sounds kinda annoying.</p><p>Normally you would try to extract the testing logic out into another function,
but that wouldn&rsquo;t let us run each test program as its own test. Luckily, macros
exist for exactly this sort of thing!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// tests/behaviour_tests.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> anyhow::Context;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> wasm_test::{Compiler, TestCase};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> wasm_test {
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$filename</span>:<span style=color:#a6e22e>ident</span>, <span style=color:#75715e>$(</span> <span style=color:#75715e>$rest</span>:<span style=color:#a6e22e>ident</span> ),<span style=color:#f92672>*</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        wasm_test!(<span style=color:#75715e>$filename</span>);
</span></span><span style=display:flex><span>        wasm_test!(<span style=color:#75715e>$($rest</span>),<span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    (<span style=color:#75715e>$filename</span>:<span style=color:#a6e22e>ident</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#75715e>$filename</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> _ <span style=color:#f92672>=</span> env_logger::try_init();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> include_str!(concat!(<span style=color:#e6db74>&#34;data/&#34;</span>, stringify!(<span style=color:#75715e>$filename</span>), <span style=color:#e6db74>&#34;.rs&#34;</span>));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> recipe <span style=color:#f92672>=</span> include_str!(concat!(<span style=color:#e6db74>&#34;data/&#34;</span>, stringify!(<span style=color:#75715e>$filename</span>), <span style=color:#e6db74>&#34;.json&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> tc <span style=color:#f92672>=</span> TestCase::parse(stringify!(<span style=color:#75715e>$filename</span>), src, recipe)
</span></span><span style=display:flex><span>                .context(<span style=color:#e6db74>&#34;Unable to load the test case&#34;</span>).unwrap();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> compiler <span style=color:#f92672>=</span> Compiler::default();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            wasm_test::run_test_case(<span style=color:#f92672>&amp;</span>compiler, <span style=color:#f92672>&amp;</span>tc).unwrap();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wasm_test!(example_program, set_outputs);
</span></span></code></pre></div><p>We can check that these tests are actually working by inserting some deliberate
bugs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>diff --git a/tests/data/example_program.json b/tests/data/example_program.json
</span></span><span style=display:flex><span>index 63d5ade..4df1806 100644
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/tests/data/example_program.json
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/tests/data/example_program.json
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -1,10 +1,12 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> {
</span></span><span style=display:flex><span>     &#34;passes&#34;: [
</span></span><span style=display:flex><span>         {
</span></span><span style=display:flex><span>             &#34;elapsed&#34;: &#34;50ms&#34;,
</span></span><span style=display:flex><span>             &#34;inputs&#34;: [],
</span></span><span style=display:flex><span>             &#34;expected_outputs&#34;: [],
</span></span><span style=display:flex><span>             &#34;expected_log_messages&#34;: [
</span></span><span style=display:flex><span><span style=color:#f92672>-                &#34;Polling&#34;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                &#34;Polling&#34;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+                &#34;Another log message&#34;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>             ]
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>     ]
</span></span><span style=display:flex><span>diff --git a/tests/data/set_outputs.rs b/tests/data/set_outputs.rs
</span></span><span style=display:flex><span>index b65ada6..aedf856 100644
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/tests/data/set_outputs.rs
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/tests/data/set_outputs.rs
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -4,7 +4,7 @@ use wasm_std::intrinsics::{
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>     self, wasm_result_t_WASM_SUCCESS as WASM_SUCCESS,
</span></span><span style=display:flex><span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-const ADDRESS: u32 = 1;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+const ADDRESS: u32 = 0;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span> #[no_mangle]
</span></span><span style=display:flex><span> pub extern &#34;C&#34; fn poll() {
</span></span></code></pre></div><p>And if we execute the test suite again, we&rsquo;re shown a couple errors:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo test
</span></span><span style=display:flex><span>Finished test [unoptimized + debuginfo] target(s) in 0.24s
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>     Running /home/michael/Documents/wasm/target/debug/deps/behaviour_tests-321146c56a045437
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>running 2 tests
</span></span><span style=display:flex><span>   Compiling set_outputs v0.1.0 (/tmp/.tmpYX6WZH)
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</span></span><span style=display:flex><span>   Compiling example_program v0.1.0 (/tmp/.tmpk3eAvE)
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.77s
</span></span><span style=display:flex><span>test example_program ... FAILED
</span></span><span style=display:flex><span>test set_outputs ... FAILED
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>failures:
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>---- example_program stdout ----
</span></span><span style=display:flex><span>thread &#39;example_program&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Output comparison failed
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>Caused by:
</span></span><span style=display:flex><span>    Unable to find log message &#34;Another log message&#34; in [(Info, &#34;Polling&#34;)]&#39;, src/libcore/result.rs:1189:5
</span></span><span style=display:flex><span>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>---- set_outputs stdout ----
</span></span><span style=display:flex><span>thread &#39;set_outputs&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: Output comparison failed
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>Caused by:
</span></span><span style=display:flex><span>    [1, 2, 3, 4, 5, 0, 0] != [0, 1, 2, 3, 4, 5, 0]&#39;, src/libcore/result.rs:1189:5
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>failures:
</span></span><span style=display:flex><span>    example_program
</span></span><span style=display:flex><span>    set_outputs
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>test result: FAILED. 0 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>error: test failed, to rerun pass &#39;--test behaviour_tests&#39;
</span></span></code></pre></div><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>It&rsquo;s been a long road, but now we have a really good foundation for working with
Wasm programs!</p><p>There&rsquo;s still a lot of room for improvement, and the host environment still looks
quite bare, but this implementation does everything I need to unblock other
parts of my project.</p><h2 id=useful-links>Useful Links
<a class=heading-link href=#useful-links><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ul><li><a href="https://www.youtube.com/watch?v=fh9WXPu0hw8" class=external-link target=_blank rel=noopener>Bringing WebAssembly outside the web with WASI</a></li><li><a href=https://wasmer.io/ class=external-link target=_blank rel=noopener>The Wasmer Website</a></li></ul></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2025
Michael-F-Bryan
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.
[<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/tree/dbb621a9a787b276f42c0f30165783a6aa3065a6 target=_blank rel=noopener>dbb621a</a>]</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=/js/mermaid.min.min.9c343a21d2c1c6ad2ffc2661e9409225290bf15165a7661b9149c9a03934034c.js integrity="sha256-nDQ6IdLBxq0v/CZh6UCSJSkL8VFlp2YbkUnJoDk0A0w="></script><script src=/js/index.min.c04ed42ce6cde47e0926ae55f072b1ff2e67af9e681a00d0ffe507800d3fd657.js integrity="sha256-wE7ULObN5H4JJq5V8HKx/y5nr55oGgDQ/+UHgA0/1lc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M80ZBKQHKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M80ZBKQHKV")}</script></body></html>