<!doctype html><html lang=en><head><title>Deserializing Binary Data Files in Rust · Michael-F-Bryan
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Michael-F-Bryan"><meta name=description content="The other day, someone on the Rust user forums posted a question
that really nerd-sniped me. They had data generated by a C++ program and were
wanting to load it into a Rust program, but when asked what format the data was
in the author didn&rsquo;t provide some something like a JSON schema or Protobuf file,
instead they just got the definition for a C struct.
A common method for &ldquo;serializing&rdquo; data in C is to create a struct and directly
write its bytes into a file, the &ldquo;deserializing&rdquo; is just a case of reading the
data out of the file and interpreting it as your type. This technique is
actually kinda genius when you think about it, it makes no intermediate copies
or heap allocations because the OS&rsquo;s read() function will literally write your
data to its destination, and there are no extra dependencies or complicated
serialization frameworks involved."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Deserializing Binary Data Files in Rust"><meta name=twitter:description content="The other day, someone on the Rust user forums posted a question that really nerd-sniped me. They had data generated by a C++ program and were wanting to load it into a Rust program, but when asked what format the data was in the author didn’t provide some something like a JSON schema or Protobuf file, instead they just got the definition for a C struct.
A common method for “serializing” data in C is to create a struct and directly write its bytes into a file, the “deserializing” is just a case of reading the data out of the file and interpreting it as your type. This technique is actually kinda genius when you think about it, it makes no intermediate copies or heap allocations because the OS’s read() function will literally write your data to its destination, and there are no extra dependencies or complicated serialization frameworks involved."><meta property="og:url" content="https://adventures.michaelfbryan.com/posts/deserializing-binary-data-files/"><meta property="og:site_name" content="Michael-F-Bryan"><meta property="og:title" content="Deserializing Binary Data Files in Rust"><meta property="og:description" content="The other day, someone on the Rust user forums posted a question that really nerd-sniped me. They had data generated by a C++ program and were wanting to load it into a Rust program, but when asked what format the data was in the author didn’t provide some something like a JSON schema or Protobuf file, instead they just got the definition for a C struct.
A common method for “serializing” data in C is to create a struct and directly write its bytes into a file, the “deserializing” is just a case of reading the data out of the file and interpreting it as your type. This technique is actually kinda genius when you think about it, it makes no intermediate copies or heap allocations because the OS’s read() function will literally write your data to its destination, and there are no extra dependencies or complicated serialization frameworks involved."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-20T00:30:00+08:00"><meta property="article:modified_time" content="2025-04-01T09:19:10+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Unsafe Rust"><link rel=canonical href=https://adventures.michaelfbryan.com/posts/deserializing-binary-data-files/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm+MTzNJdv80k+n0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/master.min.34be5ef36a820320661b4a8578382aba472d1a01092908eb30f0db81ec4031d4.css integrity="sha256-NL5e82qCAyBmG0qFeDgqukctGgEJKQjrMPDbgexAMdQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://adventures.michaelfbryan.com/>Michael-F-Bryan
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://adventures.michaelfbryan.com/posts/deserializing-binary-data-files/>Deserializing Binary Data Files in Rust</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2021-06-20T00:30:00+08:00>June 20, 2021
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
13-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/rust/>Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/unsafe-rust/>Unsafe Rust</a></span></div></div></header><div class=post-content><p>The other day, someone on the Rust user forums posted <a href=https://users.rust-lang.org/t/deserializing-a-dat-binary-file-created-in-cpp/61263 class=external-link target=_blank rel=noopener>a question</a>
that really nerd-sniped me. They had data generated by a C++ program and were
wanting to load it into a Rust program, but when asked what format the data was
in the author didn&rsquo;t provide some something like a JSON schema or Protobuf file,
instead they just got the definition for a C struct.</p><p>A common method for &ldquo;serializing&rdquo; data in C is to create a struct and directly
write its bytes into a file, the &ldquo;deserializing&rdquo; is just a case of reading the
data out of the file and interpreting it as your type. This technique is
actually kinda genius when you think about it, it makes no intermediate copies
or heap allocations because the OS&rsquo;s <code>read()</code> function will literally write your
data to its destination, and there are no extra dependencies or complicated
serialization frameworks involved.</p><p>I&rsquo;m not going to go into this technique&rsquo;s drawbacks (of which there are many&mldr;
there <em>is</em> a reason we use things like <a href=https://www.json.org/json-en.html class=external-link target=_blank rel=noopener>JSON</a> and <a href=https://developers.google.com/protocol-buffers class=external-link target=_blank rel=noopener>Protocol Buffers</a>
nowadays, after all) and instead let&rsquo;s just focus on how to read these sorts of
files.</p><p>I&rsquo;ll be approaching the problem from the perspective of someone who:</p><ul><li>Has a large number of these files and can&rsquo;t change the format for practical
reasons (backwards compatibility, time constraints, etc.)</li><li>Will be working in a safe environment with data they generated themselves
(i.e. we know the files are in the right format and people won&rsquo;t be providing
malicious input)</li><li>It&rsquo;s okay if the tool crashes - nobody will die, your servers won&rsquo;t be hacked,
and if push comes to shove we can always open a hex editor and deserialize the
data by hand</li><li>Just wants a quick-and-dirty solution to their problem</li></ul><div class="notices note"><p>The code written in this article is available <a href=https://github.com/Michael-F-Bryan/deserializing-binary-data-files class=external-link target=_blank rel=noopener>on GitHub</a>. Feel free to
browse through and steal code or inspiration.</p><p>If you found this useful or spotted a bug in the article, let me know on the
blog&rsquo;s <a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/issues class=external-link target=_blank rel=noopener>issue tracker</a>!</p></div><h2 id=how-is-the-data-generated>How is the Data Generated?
<a class=heading-link href=#how-is-the-data-generated><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To give us a better idea of what we are dealing with, let&rsquo;s create a C program
that writes some data directly to a file.</p><p>To start with we&rsquo;ll define a simplified version of the original post&rsquo;s <code>spkr</code>
struct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// examples/main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> addr1[<span style=color:#ae81ff>40</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> addr2[<span style=color:#ae81ff>40</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> phone[<span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> flags;
</span></span><span style=display:flex><span>} spkr;
</span></span></code></pre></div><p>There are two largely equivalent ways to write binary data to a file, you could
use the POSIX <a href=https://linux.die.net/man/3/write class=external-link target=_blank rel=noopener><code>write()</code></a> function to write directly to a file
descriptor, or the <a href=https://linux.die.net/man/3/fwrite class=external-link target=_blank rel=noopener><code>fwrite()</code></a> function from <code>stdio.h</code> in the C
standard library.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>ssize_t</span> <span style=color:#a6e22e>write</span>(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf, <span style=color:#66d9ef>size_t</span> count);
</span></span><span style=display:flex><span><span style=color:#66d9ef>size_t</span> <span style=color:#a6e22e>fwrite</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>restrict</span> ptr, <span style=color:#66d9ef>size_t</span> size, <span style=color:#66d9ef>size_t</span> nmemb, FILE <span style=color:#f92672>*</span><span style=color:#66d9ef>restrict</span> stream);
</span></span></code></pre></div><p>Their definitions are similar, but <code>fwrite()</code> is more portable (i.e. it also
works on Windows) so that&rsquo;s what we&rsquo;ll use.</p><p>If we ignore all error handling, this is how you would write a <code>spkr</code> to some
<code>my_speaker.dat</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// examples/main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Save a `spkr` to a file.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename, <span style=color:#66d9ef>const</span> spkr <span style=color:#f92672>*</span>speaker)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    FILE <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(filename, <span style=color:#e6db74>&#34;w&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fwrite</span>(speaker, <span style=color:#66d9ef>sizeof</span>(spkr), <span style=color:#ae81ff>1</span>, f);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fclose</span>(f);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Like I said earlier, this method of saving data <em>is</em> simple.</p><p>Loading is equally as trivial - create a <code>spkr</code> variable on the stack, use
<code>fread()</code> to read one <code>spkr</code> worth of data into the variable from the file, then
return our new <code>spkr</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// examples/main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Read a `spkr` from a file.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>spkr <span style=color:#a6e22e>load</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>filename)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    FILE <span style=color:#f92672>*</span>f <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(filename, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    spkr speaker <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fread</span>(<span style=color:#f92672>&amp;</span>speaker, <span style=color:#66d9ef>sizeof</span>(spkr), <span style=color:#ae81ff>1</span>, f);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fclose</span>(f);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> speaker;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s wrap this up in <a href=https://github.com/Michael-F-Bryan/deserializing-binary-data-files/blob/master/examples/main.c class=external-link target=_blank rel=noopener>a command-line program</a> so we can play around
with it and generate data for our Rust library to use.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ clang main.c -o main -Wall -Wpedantic
</span></span><span style=display:flex><span>$ ./main
</span></span><span style=display:flex><span>Usage:
</span></span><span style=display:flex><span>	./main generate &lt;output&gt;	write some dumy data to a file
</span></span><span style=display:flex><span>	./main load &lt;filename&gt;		print the contents of a file
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>$ ./main generate speaker.dat
</span></span><span style=display:flex><span>$ xxd speaker.dat
</span></span><span style=display:flex><span>00000000: 4a6f 7365 7068 0000 0000 0000 0000 0000  Joseph..........
</span></span><span style=display:flex><span>00000010: 0000 0000 426c 6f67 7300 0000 0000 0000  ....Blogs.......
</span></span><span style=display:flex><span>00000020: 0000 0000 0000 0000 3132 3320 4661 6b65  ........123 Fake
</span></span><span style=display:flex><span>00000030: 2053 7472 6565 7400 0000 0000 0000 0000   Street.........
</span></span><span style=display:flex><span>00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span></span><span style=display:flex><span>00000050: 4e65 7720 596f 726b 0000 0000 0000 0000  New York........
</span></span><span style=display:flex><span>00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
</span></span><span style=display:flex><span>00000070: 0000 0000 0000 0000 3230 322d 3535 352d  ........202-555-
</span></span><span style=display:flex><span>00000080: 3031 3137 0000 0000 0faa                 0117......
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>$ ./main load speaker.dat
</span></span><span style=display:flex><span>Name: Joseph Blogs
</span></span><span style=display:flex><span>Address:
</span></span><span style=display:flex><span>	123 Fake Street
</span></span><span style=display:flex><span>	New York
</span></span><span style=display:flex><span>Phone: 202-555-0117
</span></span><span style=display:flex><span>Flags: 0xAA0F
</span></span></code></pre></div><p>Okay, now we&rsquo;ve got some dummy data and a better understanding of what we are
working. Let&rsquo;s get started on the Rust version.</p><h2 id=make-a-speaker-struct>Make a Speaker Struct
<a class=heading-link href=#make-a-speaker-struct><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>After creating a new binary crate (<code>cargo new --bin deserializing-binary-data-files</code>) the first order of business is creating a Rust
equivalent for <code>spkr</code>, and for this application our struct definition must
<em>exactly</em> match <code>spkr</code>. If it doesn&rsquo;t, our fields won&rsquo;t match up and we&rsquo;ll get
garbage.</p><p>For example, if left to its own devices the Rust compiler might decide that it
can generate more efficient code by moving the <code>flags</code> field to the front of
the struct and shuffling everything down. That would mean trying to read the
<code>phone</code> field in Rust would pick up the last 2 bytes of <code>addr2</code> and the first
14 bytes of <code>phone</code>. Not ideal.</p><p>Luckily there is a way to explicitly tell the compiler to represent a struct in
memory identically to what C would do, <code>#[repr(C)]</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Default)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[repr(C)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Speaker</span> {
</span></span><span style=display:flex><span>    name: [[<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>20</span>]; <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span>    addr1: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>40</span>],
</span></span><span style=display:flex><span>    addr2: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>40</span>],
</span></span><span style=display:flex><span>    phone: [<span style=color:#66d9ef>u8</span>; <span style=color:#ae81ff>16</span>],
</span></span><span style=display:flex><span>    flags: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices note"><p>For this, we assume that <code>char</code> will be a single byte long. It&rsquo;s not
<em>technically</em> defined that way because the C standard deliberately chose to
leave it implementation defined, but with 50 years of C programs in the wild
that make this assumption, it&rsquo;s probably safe to say this is a de-facto
standard.</p></div><h2 id=blindly-assuming-the-file-contains-a-speaker>Blindly Assuming the File Contains a Speaker
<a class=heading-link href=#blindly-assuming-the-file-contains-a-speaker><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Next we need to do the actual &ldquo;deserializing&rdquo;.</p><p>The <code>fread()</code> function in C could read data directly into our <code>spkr</code> variable
because it accepts a <code>void*</code> pointer as the destination, and all pointers
implicitly coerce to <code>void*</code>.</p><p>Unfortunately for us the corresponding API, the <a href=https://doc.rust-lang.org/std/io/trait.Read.html class=external-link target=_blank rel=noopener><code>std::io::Read</code></a> trait,
insists that our programs are type-safe and will only write into a byte buffer
(<code>&amp;mut [u8]</code>).</p><p>Instead, when creating a <code>load()</code> constructor for loading a <code>Speaker</code> from a
reader we&rsquo;ll create a <code>Speaker</code> variable where all the fields are set to a
&ldquo;sane&rdquo; default so we avoid passing an uninitialized buffer to our reader&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::io::{Error, Read};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Speaker {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(<span style=color:#66d9ef>mut</span> reader: <span style=color:#a6e22e>impl</span> Read) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create a Speaker where all the fields are set to some sane default
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// (typically all zeroes)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> speaker <span style=color:#f92672>=</span> Speaker::default();
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; Then tell the compiler to treat our <code>speaker</code> variable as a big byte
array that we can data into&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Speaker {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(<span style=color:#66d9ef>mut</span> reader: <span style=color:#a6e22e>impl</span> Read) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Get a slice which treats the `speaker` variable as a byte array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> buffer: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [<span style=color:#66d9ef>u8</span>] <span style=color:#f92672>=</span> std::slice::from_raw_parts_mut(
</span></span><span style=display:flex><span>                speaker.as_mut_ptr().cast(),
</span></span><span style=display:flex><span>                mem::size_of::<span style=color:#f92672>&lt;</span>Speaker<span style=color:#f92672>&gt;</span>(),
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Read exactly that many bytes from the reader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            reader.read_exact(buffer)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; then once we know the <code>speaker</code> has been completely filled with data from
the reader we just need to return it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Speaker {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(<span style=color:#66d9ef>mut</span> reader: <span style=color:#a6e22e>impl</span> Read) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Our `speaker` has now been updated with data from the reader.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Ok(speaker)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In Rust it&rsquo;s always a good idea to add a comment above your <code>unsafe</code> blocks
noting down your assumptions and why the <code>unsafe</code> block is correct and won&rsquo;t
break memory safety.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Speaker {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(<span style=color:#66d9ef>mut</span> reader: <span style=color:#a6e22e>impl</span> Read) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Safety: All the fields in a Speaker are valid for all possible bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// combinations.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The primary reason for this being sound is that a <code>Speaker</code> only contains
integers and arrays of integers, and an integer is valid for all possible bit
patterns. That means blindly copying bytes from (possibly maliciously crafted)
input into a <code>Speaker</code> can&rsquo;t introduce memory safety issues into our
<code>Speaker::load()</code> function. Sure it could give us data that doesn&rsquo;t make sense,
but we&rsquo;d still have valid byte arrays in our byte array fields and a valid <code>i16</code>
in our <code>flags</code> field.</p><div class="notices warning"><p>This assumption <strong>isn&rsquo;t</strong> correct in general. It&rsquo;s one of the reasons the docs
for <a href=https://doc.rust-lang.org/std/mem/fn.transmute.html class=external-link target=_blank rel=noopener><code>std::mem::transmute()</code></a> are full of warnings saying there are
plenty of better ways to do things and <code>transmute()</code> should be a tool of last
resort.</p><p>For example, the <code>Speaker</code> struct couldn&rsquo;t container a string reference (<code>&amp;str</code>)
because references must always be non-null, aligned, point at valid instances of
that type, and not outlive the things they refer to. Of the 2<sup>64</sup>
different possible bit patterns on a 64-bit machine, that may only be correct
for a small handful of values.</p><p>As such, it wouldn&rsquo;t be sound to give our <code>Speaker</code> a <code>&amp;str</code> or <code>Vec&lt;T></code> field
unless we had some outside information which makes extra guarantees. If the
caller <em>could</em> provide those guarantees then we would be able to mark the entire
<code>Speaker::load()</code> function as <code>unsafe</code> and make memory safety their problem.</p></div><h2 id=making-things-convenient>Making Things Convenient
<a class=heading-link href=#making-things-convenient><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Now, C&rsquo;s <code>printf()</code> is more than happy to take a pointer to some bytes and
interpret them as text, but if we tried to print <code>Speaker</code>&rsquo;s fields at the
moment we&rsquo;d get something useless like <code>[0x4a, 0x6f, 0x73, 0x65, 0x70, 0x68, 0x0a, 0x00, 0x00, 0x00]</code> instead of the <code>"Joseph"</code> that we expect.</p><p>This is because Rust treats all arrays of bytes as arrays of bytes and doesn&rsquo;t
attach any extra meaning to them. If we want to treat them like strings then
we&rsquo;ll need to use <a href=https://doc.rust-lang.org/std/str/fn.from_utf8.html class=external-link target=_blank rel=noopener><code>std::str::from_utf8()</code></a> to convert our
byte arrays to a UTF-8 <code>&amp;str</code>.</p><p>From the way our C is implemented, if a string field isn&rsquo;t completely filled
with text it will be padded out with zeroes. This is particularly helpful for
C programs because it means our fields always have trailing null bytes (as
long as we don&rsquo;t overflow).</p><p>In Rust, we don&rsquo;t to include these trailing null bytes in the final output (null
is a valid UTF-8 character), so let&rsquo;s make a helper function that takes a byte
array, trims off any trailing nulls, then tries to interpret it as UTf-8.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>c_string</span>(bytes: <span style=color:#66d9ef>&amp;</span>[<span style=color:#66d9ef>u8</span>]) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> bytes_without_null <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> bytes.iter().position(<span style=color:#f92672>|&amp;</span>b<span style=color:#f92672>|</span> b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Some(ix) <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>&amp;</span>bytes[<span style=color:#f92672>..</span>ix],
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> bytes,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std::<span style=color:#66d9ef>str</span>::from_utf8(bytes_without_null).ok()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With our <code>c_string()</code> function in hand we are now ready to give <code>Speaker</code> some
getter methods.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Speaker {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>address_line_1</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> { c_string(<span style=color:#f92672>&amp;</span>self.addr1) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>address_line_2</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> { c_string(<span style=color:#f92672>&amp;</span>self.addr2) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>phone_number</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> { c_string(<span style=color:#f92672>&amp;</span>self.phone) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>name</code> field is a bit more interesting because it contains two strings in
an array, presumably the first and last names.</p><p>To preserve the semantics that a <code>name</code> contains two strings, we can use a
mixture of destructuring and the <code>?</code> operator to create a getter that returns
the first and last names only when they are both valid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Speaker {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>name</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>)<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> [first, last] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>self.name;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> first <span style=color:#f92672>=</span> c_string(first)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> last <span style=color:#f92672>=</span> c_string(last)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Some((first, last))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=tests>Tests
<a class=heading-link href=#tests><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>We&rsquo;ve now got a <code>Speaker::load()</code> constructor and some convenient getter methods
for interpreting the fields so I figure it&rsquo;s time to write some tests.</p><p>First, we&rsquo;ll take the bytes from the <code>speaker.dat</code> generated earlier and save
them as a byte literal. Conveniently, the <code>xxd</code> tool has a flag which prints
the input in a form that can be included in source code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cat speaker.dat | xxd -i
</span></span><span style=display:flex><span>  0x4a, 0x6f, 0x73, 0x65, 0x70, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style=display:flex><span>  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x6c, 0x6f, 0x67,
</span></span><span style=display:flex><span>  0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style=display:flex><span>  0x00, 0x00, 0x00, 0x00, 0x31, 0x32, 0x33, 0x20, 0x46, 0x61, 0x6b, 0x65,
</span></span><span style=display:flex><span>  0x20, 0x53, 0x74, 0x72, 0x65, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style=display:flex><span>  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style=display:flex><span>  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x65, 0x77, 0x20,
</span></span><span style=display:flex><span>  0x59, 0x6f, 0x72, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style=display:flex><span>  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style=display:flex><span>  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style=display:flex><span>  0x32, 0x30, 0x32, 0x2d, 0x35, 0x35, 0x35, 0x2d, 0x30, 0x31, 0x31, 0x37,
</span></span><span style=display:flex><span>  0x00, 0x00, 0x00, 0x00, 0x0f, 0xaa
</span></span></code></pre></div><p>All we need to do is create a new test module and paste it into a <code>SPEAKER_DAT</code>
constant.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> std::io::Cursor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>SPEAKER_DAT</span>: [<span style=color:#66d9ef>u8</span>; mem::size_of::<span style=color:#f92672>&lt;</span>Speaker<span style=color:#f92672>&gt;</span>()] <span style=color:#f92672>=</span> [ <span style=color:#f92672>..</span>. ];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can write a test which deserializes our <em>Joseph Blogs</em> speaker&rsquo;s
information and compares it to what the C code generated.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/main.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>deserialize_joe_bloggs</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> reader <span style=color:#f92672>=</span> Cursor::new(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>SPEAKER_DAT</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> got <span style=color:#f92672>=</span> Speaker::load(reader).unwrap();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(got.name().unwrap(), (<span style=color:#e6db74>&#34;Joseph&#34;</span>, <span style=color:#e6db74>&#34;Blogs&#34;</span>));
</span></span><span style=display:flex><span>        assert_eq!(got.address_line_1().unwrap(), <span style=color:#e6db74>&#34;123 Fake Street&#34;</span>);
</span></span><span style=display:flex><span>        assert_eq!(got.address_line_2().unwrap(), <span style=color:#e6db74>&#34;New York&#34;</span>);
</span></span><span style=display:flex><span>        assert_eq!(got.phone_number().unwrap(), <span style=color:#e6db74>&#34;202-555-0117&#34;</span>);
</span></span><span style=display:flex><span>        assert_eq!(got.flags, <span style=color:#ae81ff>0xAA0F</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Our test passes, of course.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo test
</span></span><span style=display:flex><span>    Finished test [unoptimized + debuginfo] target(s) in 0.03s
</span></span><span style=display:flex><span>     Running unittests (/home/michael/Documents/deserializing-binary-data-files/target/debug/deps/reading_data_files-f34629f4e016d364)
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>running 1 test
</span></span><span style=display:flex><span>test tests::deserialize_joe_bloggs ... ok
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 4 filtered out; finished in 0.00s
</span></span></code></pre></div><h2 id=a-note-on-packing>A Note on Packing
<a class=heading-link href=#a-note-on-packing><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>There is this concept called <a href=https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked class=external-link target=_blank rel=noopener>&ldquo;packing&rdquo;</a> which is quite important in
telling the compiler how to lay out our <code>Speaker</code> and <code>spkr</code> structs in memory.
We are interpreting a bunch of bytes as a <code>Speaker</code> it is very important for us
that <code>Speaker</code> and <code>spkr</code> are laid out identically otherwise we&rsquo;ll get garbage.</p><p>You see, processors really like it when things are lined up in memory correctly
and they often need to do extra work when they aren&rsquo;t lined up (which kills
performance) or will just error out altogether (which kills your program). For
example, a <code>u8</code> can be placed at addresses that are multiples of 1 byte (i.e.
anywhere), a <code>u32</code> can be placed at multiples of 4 bytes, and so on.</p><p>To deal with this alignment issue, compilers will insert some unused bytes
(often called &ldquo;padding&rdquo;) between fields to make sure they line up correctly -
this is actually what the <code>#[repr(C)]</code> attribute does. If we want to tell the
compiler <em>not</em> to insert this spacing we can use <code>#[repr(packed)]</code> to tell the
compiler <em>&ldquo;this struct&rsquo;s bytes must be <strong>packed</strong> together as closely as possible&rdquo;</em>.</p><p>Most binary formats don&rsquo;t care about these padding bytes because they want files
to be as compact as possible, so it&rsquo;s not uncommon to see a <code>#[repr(packed)]</code>
(or its C cousin, <code>__attribute__((__packed__))</code> on GCC and
<code>__attribute__((packed))</code> on Clang) next to struct definitions when they are
using this direct reading/writing method of serializing data.</p><p>We get lucky here because the <code>flags</code> field is at offset 202 (which is a
multiple of 2 bytes) so we didn&rsquo;t need to do anything special, but it&rsquo;s still
good to know. It may also help explain why you&rsquo;ll often see random fields named
<code>spare</code> or <code>unused</code> in a C struct definition.</p><h2 id=conclusions>Conclusions
<a class=heading-link href=#conclusions><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>It&rsquo;s not something you&rsquo;ll need to (or want to) use too often, but knowing how to
read/write data directly to some file without needing any complicated
serialization frameworks might be something you&rsquo;ll use some day.</p><p>That said, there are a lot of better alternatives out there, with most of them
allowing you to write code that has similar performance characteristics with no
need for <code>unsafe</code>.</p><p>Personally, I would definitely reach for a better tool (probably a parsing
library like <a href=https://crates.io/crates/nom class=external-link target=_blank rel=noopener><code>nom</code></a> or <a href=https://crates.io/crates/binread class=external-link target=_blank rel=noopener><code>binread</code></a>) if this was an application I
cared about or if I didn&rsquo;t have full control over the input. However, for
quick-and-dirty tools where your primary goal is to <em>&ldquo;do whatever C does&rdquo;</em>, this
technique works pretty well.</p></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2025
Michael-F-Bryan
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.
[<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/tree/dbb621a9a787b276f42c0f30165783a6aa3065a6 target=_blank rel=noopener>dbb621a</a>]</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=/js/mermaid.min.min.9c343a21d2c1c6ad2ffc2661e9409225290bf15165a7661b9149c9a03934034c.js integrity="sha256-nDQ6IdLBxq0v/CZh6UCSJSkL8VFlp2YbkUnJoDk0A0w="></script><script src=/js/index.min.c04ed42ce6cde47e0926ae55f072b1ff2e67af9e681a00d0ffe507800d3fd657.js integrity="sha256-wE7ULObN5H4JJq5V8HKx/y5nr55oGgDQ/+UHgA0/1lc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M80ZBKQHKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M80ZBKQHKV")}</script></body></html>