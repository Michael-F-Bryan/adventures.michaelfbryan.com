<!doctype html><html lang=en><head><title>Line Simplification with Ramerâ€“Douglasâ€“Peucker Â· Michael-F-Bryan
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Michael-F-Bryan"><meta name=description content="The other day I needed to do a fairly routine graphical operation, to
&ldquo;simplify&rdquo; a polyline with many points into a simpler polyline which has
roughly the same shape plus or minus some tolerance factor.
My actual use case was in sending linear movements to a CNC machine. Drawings
are defined using floating point numbers and can be &ldquo;accurate&rdquo; to about 7-15
decimal places (depending on if you use floats or doubles) but when you take
the machine&rsquo;s mechanical tolerances and material effects into account the
final cut is only really accurate to about 1 decimal place (0.1 mm). If I
were to simplify the path with a tolerance of, say, 0.05 mm I could massively
reduce the number of points sent to the machine (which reduces the amount of
data sent, buffer sizes, communications overhead, etc.) with minimal effect
on the accuracy."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Line Simplification with Ramerâ€“Douglasâ€“Peucker"><meta name=twitter:description content="The other day I needed to do a fairly routine graphical operation, to â€œsimplifyâ€ a polyline with many points into a simpler polyline which has roughly the same shape plus or minus some tolerance factor.
My actual use case was in sending linear movements to a CNC machine. Drawings are defined using floating point numbers and can be â€œaccurateâ€ to about 7-15 decimal places (depending on if you use floats or doubles) but when you take the machineâ€™s mechanical tolerances and material effects into account the final cut is only really accurate to about 1 decimal place (0.1 mm). If I were to simplify the path with a tolerance of, say, 0.05 mm I could massively reduce the number of points sent to the machine (which reduces the amount of data sent, buffer sizes, communications overhead, etc.) with minimal effect on the accuracy."><meta property="og:url" content="https://adventures.michaelfbryan.com/posts/line-simplification/"><meta property="og:site_name" content="Michael-F-Bryan"><meta property="og:title" content="Line Simplification with Ramerâ€“Douglasâ€“Peucker"><meta property="og:description" content="The other day I needed to do a fairly routine graphical operation, to â€œsimplifyâ€ a polyline with many points into a simpler polyline which has roughly the same shape plus or minus some tolerance factor.
My actual use case was in sending linear movements to a CNC machine. Drawings are defined using floating point numbers and can be â€œaccurateâ€ to about 7-15 decimal places (depending on if you use floats or doubles) but when you take the machineâ€™s mechanical tolerances and material effects into account the final cut is only really accurate to about 1 decimal place (0.1 mm). If I were to simplify the path with a tolerance of, say, 0.05 mm I could massively reduce the number of points sent to the machine (which reduces the amount of data sent, buffer sizes, communications overhead, etc.) with minimal effect on the accuracy."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-23T21:56:00+08:00"><meta property="article:modified_time" content="2025-04-01T09:19:10+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Algorithms"><link rel=canonical href=https://adventures.michaelfbryan.com/posts/line-simplification/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm+MTzNJdv80k+n0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/master.min.34be5ef36a820320661b4a8578382aba472d1a01092908eb30f0db81ec4031d4.css integrity="sha256-NL5e82qCAyBmG0qFeDgqukctGgEJKQjrMPDbgexAMdQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://adventures.michaelfbryan.com/>Michael-F-Bryan
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://adventures.michaelfbryan.com/posts/line-simplification/>Line Simplification with Ramerâ€“Douglasâ€“Peucker</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2020-02-23T21:56:00+08:00>February 23, 2020
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
9-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/rust/>Rust</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/algorithms/>Algorithms</a></span></div></div></header><div class=post-content><p>The other day I needed to do a fairly routine graphical operation, to
&ldquo;simplify&rdquo; a polyline with many points into a simpler polyline which has
roughly the same shape plus or minus some <code>tolerance</code> factor.</p><p>My actual use case was in sending linear movements to a CNC machine. Drawings
are defined using floating point numbers and can be &ldquo;accurate&rdquo; to about 7-15
decimal places (depending on if you use floats or doubles) but when you take
the machine&rsquo;s mechanical tolerances and material effects into account the
final cut is only really accurate to about 1 decimal place (0.1 mm). If I
were to simplify the path with a tolerance of, say, 0.05 mm I could massively
reduce the number of points sent to the machine (which reduces the amount of
data sent, buffer sizes, communications overhead, etc.) with minimal effect
on the accuracy.</p><p>Other places where this operation can be useful are:</p><ul><li>Cleaning up paths from from &ldquo;noisy&rdquo; data sources (imagine getting pixel
locations from an <a href=https://en.wikipedia.org/wiki/Edge_detection class=external-link target=_blank rel=noopener>edge detection</a> algorithm)</li><li>When you just need a general shape and more points would have a large
negative effect on performance for the consumer (e.g. a <a href=https://en.wikipedia.org/wiki/Nesting_%28process%29 class=external-link target=_blank rel=noopener>nesting
algorithm</a>).</li></ul><p>My go-to tool for this sort of operation is the <a href=https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm class=external-link target=_blank rel=noopener>Ramerâ€“Douglasâ€“Peucker
algorithm</a>, and I thought this would make a nice addition to the
<a href=https://github.com/Michael-F-Bryan/arcs class=external-link target=_blank rel=noopener>arcs</a> library I&rsquo;ve been working on over the last couple months.</p><div class="notices note"><p>The code written in this article is available <a href=https://github.com/Michael-F-Bryan/arcs class=external-link target=_blank rel=noopener>on GitHub</a>. Feel free to
browse through and steal code or inspiration.</p><p>If you found this useful or spotted a bug, let me know on the blog&rsquo;s
<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com class=external-link target=_blank rel=noopener>issue tracker</a>!</p></div><h2 id=the-algorithm>The Algorithm
<a class=heading-link href=#the-algorithm><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The algorithm itself uses a remarkably simple recursive algorithm,</p><ol><li>Mark the <code>first</code> and <code>last</code> points as kept</li><li>Find the point, <code>p</code> that is the farthest from the first-last line segment.
If there are no points between <code>first</code> and <code>last</code> we are done (the base case)</li><li>If <code>p</code> is closer than <code>tolerance</code> units to the line segment then
everything between <code>first</code> and <code>last</code> can be discarded</li><li>Otherwise, mark <code>p</code> as kept and repeat steps 1-4 using the points between
<code>first</code> and <code>p</code> and between <code>p</code> and <code>last</code> (the call to recursion)</li></ol><p>This animation from <a href=https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm class=external-link target=_blank rel=noopener>the Wikipedia article</a> can help wrap your head
around how it works.</p><figure><a href=https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm><img src=https://upload.wikimedia.org/wikipedia/commons/3/30/Douglas-Peucker_animated.gif alt="Visualisation of the Ramer-Douglas-Peucker algorithm"></a><figcaption><p>Visualisation of the Ramer-Douglas-Peucker algorithm</p></figcaption></figure><p>Like most divide-and-conquer algorithms, in the ideal case this completes in
<code>O(n log n)</code> time. However, if you hit an edge case where the &ldquo;furthest&rdquo;
point is right next to the endpoints this can blow out to <code>O(n^2)</code>.</p><p>I don&rsquo;t normally worry about computational complexity too often (computers
are fast), but because it&rsquo;s quite common for my application to work with
drawings containing hundreds of thousands of points it&rsquo;s something to keep an
eye on.</p><h2 id=the-implementation>The Implementation
<a class=heading-link href=#the-implementation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To start, let&rsquo;s add a <code>line_simplification</code> module to <code>arcs::algorithms</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span> // arcs/src/algorithms/mod.rs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> mod length;
</span></span><span style=display:flex><span><span style=color:#a6e22e>+mod line_simplification;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> mod scale;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> pub use length::Length;
</span></span><span style=display:flex><span><span style=color:#a6e22e>+pub use line_simplification::simplify;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> pub use scale::Scale;
</span></span></code></pre></div><p>I&rsquo;ve also stubbed out a <code>simplify</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> euclid::{Length, Point2D};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Decimate a curve composed of line segments to a *&#34;simpler&#34;* curve with fewer
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// points.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>///
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// The algorithm defines *&#34;simpler&#34;* based on the maximum distance
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// (`tolerance`) between the original curve and the simplified curve.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>///
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// You may want to research the [Ramerâ€“Douglasâ€“Peucker algorithm][wiki] for
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// the exact details and assumptions that can be made.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>///
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// [wiki]: https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simplify</span><span style=color:#f92672>&lt;</span>Space<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    points: <span style=color:#66d9ef>&amp;</span>[Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>],
</span></span><span style=display:flex><span>    tolerance: <span style=color:#a6e22e>Length</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    unimplemented!()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices note"><p>You&rsquo;ll notice that the function signature has this funny <code>Space</code> generic type
variable. The <code>arcs</code> crate takes advantage of <a href=https://crates.io/crates/euclid class=external-link target=_blank rel=noopener>the <code>euclid</code> crate</a>&rsquo;s
ability to &ldquo;tag&rdquo; a type with the coordinate space it can be used with, and
because this algorithm isn&rsquo;t specific to any one coordinate space we&rsquo;re
making it generic over <em>all</em> coordinate spaces.</p><p>You can think of this <em>&ldquo;Coordinate Space&rdquo;</em> idea as the graphical version of
units. It&rsquo;s really annoying to accidentally mix up locations on a screen
(<em>Canvas Space</em>, with the origin at the top-left) with locations in a drawing
(<em>Drawing Space</em>, Cartesian coordinates which can go to infinity), so
tagging points and lengths with their intended space lets us
statically prevent the types of conversion problems that destroyed the <a href=https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure class=external-link target=_blank rel=noopener>Mars
Climate Orbiter</a>.</p></div><p>To implement this I&rsquo;m going to procedurally build up a new <code>Vec</code> of points,
passing a <code>&amp;mut Vec&lt;_></code> to the function doing the actual recursion.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simplify</span><span style=color:#f92672>&lt;</span>Space<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    points: <span style=color:#66d9ef>&amp;</span>[Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>],
</span></span><span style=display:flex><span>    tolerance: <span style=color:#a6e22e>Length</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> points.len() <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> points.to_vec();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> buffer <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// push the first point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    buffer.push(points[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// then simplify every point in between the start and end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    simplify_points(<span style=color:#f92672>&amp;</span>points[<span style=color:#f92672>..</span>], tolerance, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> buffer);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// and finally the last one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    buffer.push(<span style=color:#f92672>*</span>points.last().unwrap());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    buffer
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next we need to implement this <code>simplify_points()</code> function.</p><p>We can use <code>if let</code> and the really handy <a href=https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html class=external-link target=_blank rel=noopener>slice pattern</a>
feature (stabilised in Rust 1.42) to extract the <code>first</code>, <code>last</code>, and <code>rest</code>.
This gives us everything we need to create a <code>Line</code> from <code>first</code> and <code>last</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simplify_points</span><span style=color:#f92672>&lt;</span>Space<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    points: <span style=color:#66d9ef>&amp;</span>[Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>],
</span></span><span style=display:flex><span>    tolerance: <span style=color:#a6e22e>Length</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    buffer: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span>Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> [first, rest <span style=color:#f92672>@</span> <span style=color:#f92672>..</span>, last] <span style=color:#f92672>=</span> points {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> line_segment <span style=color:#f92672>=</span> Line::new(<span style=color:#f92672>*</span>first, <span style=color:#f92672>*</span>last);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next we can try to find the point whose perpendicular distance is furthest from
<code>line_segment</code>.</p><p>Ideally I&rsquo;d like to use the <a href=https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max_by_key class=external-link target=_blank rel=noopener><code>Iterator::max_by_key()</code></a> method to
find the index of the furthest point where our &ldquo;key&rdquo; function uses
<code>Line::perpendicular_distance_to()</code>, but that returns a reference to the item
and not its index&mldr; So to make the code cleaner I ended up rolling my own
<code>max_by_key()</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simplify_points</span><span style=color:#f92672>&lt;</span>Space<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    points: <span style=color:#66d9ef>&amp;</span>[Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>],
</span></span><span style=display:flex><span>    tolerance: <span style=color:#a6e22e>Length</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    buffer: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span>Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> [first, rest <span style=color:#f92672>@</span> <span style=color:#f92672>..</span>, last] <span style=color:#f92672>=</span> points {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> line_segment <span style=color:#f92672>=</span> Line::new(<span style=color:#f92672>*</span>first, <span style=color:#f92672>*</span>last);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((ix, distance)) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            max_by_key(rest, <span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> line_segment.perpendicular_distance_to(<span style=color:#f92672>*</span>p))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>max_by_key</span><span style=color:#f92672>&lt;</span>T, F, K<span style=color:#f92672>&gt;</span>(items: <span style=color:#66d9ef>&amp;</span>[T], <span style=color:#66d9ef>mut</span> key_func: <span style=color:#a6e22e>F</span>) -&gt; Option<span style=color:#f92672>&lt;</span>(<span style=color:#66d9ef>usize</span>, K)<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    F: FnMut(<span style=color:#f92672>&amp;</span>T) -&gt; <span style=color:#a6e22e>K</span>,
</span></span><span style=display:flex><span>    K: PartialOrd,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> best_so_far <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i, item) <span style=color:#66d9ef>in</span> items.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> key <span style=color:#f92672>=</span> key_func(item);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> is_better <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> best_so_far {
</span></span><span style=display:flex><span>            Some((_, <span style=color:#66d9ef>ref</span> best_key)) <span style=color:#f92672>=&gt;</span> key <span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span>best_key,
</span></span><span style=display:flex><span>            None <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_better {
</span></span><span style=display:flex><span>            best_so_far <span style=color:#f92672>=</span> Some((i, key));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    best_so_far
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you&rsquo;re keeping track we&rsquo;ve completed step 2 from <a href=#the-algorithm>the algorithm
section</a>.</p><p>Now if the <code>distance</code> is greater than our <code>tolerance</code> we need to recurse and
add the furthest point to our <code>buffer</code>.</p><p>The only real difficulty here is that the <code>ix</code> returned by <code>max_by_key()</code> is
an index into <code>rest</code>, not <code>points</code>&mldr; I originally forgot this bit and had an
off-by-one error that resulted in infinite recursion and blowing the stack ðŸ˜Š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simplify_points</span><span style=color:#f92672>&lt;</span>Space<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>    points: <span style=color:#66d9ef>&amp;</span>[Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>],
</span></span><span style=display:flex><span>    tolerance: <span style=color:#a6e22e>Length</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    buffer: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Vec<span style=color:#f92672>&lt;</span>Point2D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span>, Space<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> [first, rest <span style=color:#f92672>@</span> <span style=color:#f92672>..</span>, last] <span style=color:#f92672>=</span> points {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> line_segment <span style=color:#f92672>=</span> Line::new(<span style=color:#f92672>*</span>first, <span style=color:#f92672>*</span>last);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some((ix, distance)) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            max_by_key(rest, <span style=color:#f92672>|</span>p<span style=color:#f92672>|</span> line_segment.perpendicular_distance_to(<span style=color:#f92672>*</span>p))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> distance <span style=color:#f92672>&gt;</span> tolerance {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// note: index is the index into `rest`, but we want it relative
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// to `point`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> ix <span style=color:#f92672>=</span> ix <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                simplify_points(<span style=color:#f92672>&amp;</span>points[<span style=color:#f92672>..=</span>ix], tolerance, buffer);
</span></span><span style=display:flex><span>                buffer.push(points[ix]);
</span></span><span style=display:flex><span>                simplify_points(<span style=color:#f92672>&amp;</span>points[ix<span style=color:#f92672>..</span>], tolerance, buffer);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; And that&rsquo;s pretty much it. We&rsquo;ve implemented the full
<em>Ramer-Douglas-Peucker algorithm</em> in about 50 lines or Rust.</p><div class="notices tip"><p>When you&rsquo;re doing recursion it&rsquo;s always nice to do a sanity check and make sure
you&rsquo;ve implemented the reduction and base cases properly, otherwise you risk
infinite recursion&mldr;</p><p>For our base case, the <code>if let [first, .., last]</code> slice pattern means we&rsquo;ll stop
recursing when there are less than 2 points.</p><p>Also, because <code>rest</code> gets smaller and smaller every time we recurse we&rsquo;re
constantly dividing the problem into smaller and smaller pieces.</p></div><h2 id=writing-tests>Writing Tests
<a class=heading-link href=#writing-tests><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>At this point we know our code compiles, but is it actually correct?</p><p>We can start off with lines of 0, 1, or 2 points, because they&rsquo;re already as
simple as they&rsquo;re going to get.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>super</span>::<span style=color:#f92672>*</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>use</span> <span style=color:#66d9ef>crate</span>::Point;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>empty_line</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> points: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Vec::new();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> got <span style=color:#f92672>=</span> simplify(<span style=color:#f92672>&amp;</span>points, Length::new(<span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert!(got.is_empty());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_with_one_point</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> points <span style=color:#f92672>=</span> vec![Point::new(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> got <span style=color:#f92672>=</span> simplify(<span style=color:#f92672>&amp;</span>points, Length::new(<span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(got, points);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>line_with_two_points</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> points <span style=color:#f92672>=</span> vec![Point::new(<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>), Point::new(<span style=color:#ae81ff>10.0</span>, <span style=color:#ae81ff>2.0</span>)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> got <span style=color:#f92672>=</span> simplify(<span style=color:#f92672>&amp;</span>points, Length::new(<span style=color:#ae81ff>1.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(got, points);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What about a perfectly straight line containing 100 points? The simplified
version should only contain the start and end points.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simplify_a_straight_line_to_two_points</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> points: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>100</span>).map(<span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> Point::new(i <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>, <span style=color:#ae81ff>0.0</span>)).collect();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> should_be <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>[points[<span style=color:#ae81ff>0</span>], points[<span style=color:#ae81ff>99</span>]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> got <span style=color:#f92672>=</span> simplify(<span style=color:#f92672>&amp;</span>points, Length::new(<span style=color:#ae81ff>0.1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(got, should_be);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, let&rsquo;s add a bit of movement to the various points in this line. I&rsquo;m going
to use <code>sin</code> to add a bit of &ldquo;randomness&rdquo; to each point&rsquo;s vertical component.
As long as the vertical movement is within our threshold all points between the
start and end should be simplified out.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simplify_a_horizontal_line_with_small_amounts_of_vertical_jitter</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> max_jitter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> points: Vec<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>i<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> jitter <span style=color:#f92672>=</span> max_jitter <span style=color:#f92672>*</span> (i <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>100.0</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>PI</span>).sin();
</span></span><span style=display:flex><span>                Point::new(i <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>, jitter)
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> should_be <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>[points[<span style=color:#ae81ff>0</span>], points[<span style=color:#ae81ff>99</span>]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> got <span style=color:#f92672>=</span> simplify(<span style=color:#f92672>&amp;</span>points, Length::new(max_jitter <span style=color:#f92672>*</span> <span style=color:#ae81ff>2.0</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(got, should_be);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As a fun fact, if you were to graph this you&rsquo;d see a sine wave between 0 and 99
with a period of 50 and amplitude of <code>0.1</code>.</p><p>Finally I thought I&rsquo;d try a more realistic curve to make sure the tests so far
haven&rsquo;t added some bias due to their contrived nature.</p><p>For this, I needed to pull out the most sophisticated tool in my mathematical
toolbox.</p><p><img src=/img/line-simplification-sketch.png alt="A hand-drawn sketch of several points with annotations showing how the path would be simplified"></p><p>&mldr; Pen and paper.</p><p>I&rsquo;ve drawn a series of points on a set of cartesian coordinates, and circled the
points (blue) that would be kept. By tracing around my ruler (red) I can emulate
the tolerance area, with anything inside the ruler boundary being discarded.</p><p>By measuring the location of each point we can write one last test.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// arcs/src/algorithms/line_simplification.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[cfg(test)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>mod</span> tests {
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simplify_more_realistic_line</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Found by drawing it out on paper and using a ruler to determine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// point coordinates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> line <span style=color:#f92672>=</span> vec![
</span></span><span style=display:flex><span>            Point::new(<span style=color:#f92672>-</span><span style=color:#ae81ff>43.0</span>, <span style=color:#ae81ff>8.0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#f92672>-</span><span style=color:#ae81ff>24.0</span>, <span style=color:#ae81ff>19.0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#f92672>-</span><span style=color:#ae81ff>13.0</span>, <span style=color:#ae81ff>23.0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#f92672>-</span><span style=color:#ae81ff>8.0</span>, <span style=color:#ae81ff>36.0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>7.0</span>, <span style=color:#ae81ff>40.0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>24.0</span>, <span style=color:#ae81ff>12.0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>44.0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>6.0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>57.0</span>, <span style=color:#ae81ff>2.0</span>),
</span></span><span style=display:flex><span>            Point::new(<span style=color:#ae81ff>70.0</span>, <span style=color:#ae81ff>7.0</span>),
</span></span><span style=display:flex><span>        ];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> should_be <span style=color:#f92672>=</span> vec![line[<span style=color:#ae81ff>0</span>], line[<span style=color:#ae81ff>4</span>], line[<span style=color:#ae81ff>6</span>], line[<span style=color:#ae81ff>8</span>]];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> ruler_width <span style=color:#f92672>=</span> Length::new(<span style=color:#ae81ff>20.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> got <span style=color:#f92672>=</span> simplify(<span style=color:#f92672>&amp;</span>line, ruler_width <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assert_eq!(got, should_be);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusions>Conclusions
<a class=heading-link href=#conclusions><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>This was a lot shorter than my <a href=https://adventures.michaelfbryan.com/posts/pragmatic-global-state/>usual</a> <a href=https://adventures.michaelfbryan.com/posts/ecs-outside-of-games/>deep</a> <a href=https://adventures.michaelfbryan.com/posts/wasm-as-a-platform-for-abstraction/>dives</a> into complex
programming topics (I think the average read time for articles on my blog is
around 25 minutes?), but I hope it&rsquo;ll be useful if you ever need to
implement line simplification.</p><p>Even if you aren&rsquo;t going to implement line simplification any time soon the
algorithm itself is also quite elegant, so you might appreciate it for its
aesthetic qualities.</p><p>In the meantime I think I&rsquo;ll keep adding bits and pieces to <a href=https://github.com/Michael-F-Bryan/arcs class=external-link target=_blank rel=noopener>arcs</a> and
<a href=https://github.com/Michael-F-Bryan/rustmatic class=external-link target=_blank rel=noopener>experimenting with motion control</a> when I have time. Let me know
if either of those topics interest you and I&rsquo;ll do some more write-ups as
various things get implemented.</p></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>Â©
2025
Michael-F-Bryan
Â·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.
[<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/tree/dbb621a9a787b276f42c0f30165783a6aa3065a6 target=_blank rel=noopener>dbb621a</a>]</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=/js/mermaid.min.min.9c343a21d2c1c6ad2ffc2661e9409225290bf15165a7661b9149c9a03934034c.js integrity="sha256-nDQ6IdLBxq0v/CZh6UCSJSkL8VFlp2YbkUnJoDk0A0w="></script><script src=/js/index.min.c04ed42ce6cde47e0926ae55f072b1ff2e67af9e681a00d0ffe507800d3fd657.js integrity="sha256-wE7ULObN5H4JJq5V8HKx/y5nr55oGgDQ/+UHgA0/1lc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M80ZBKQHKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M80ZBKQHKV")}</script></body></html>