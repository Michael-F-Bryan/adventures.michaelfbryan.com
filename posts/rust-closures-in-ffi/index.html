<!doctype html><html lang=en><head><title>Rust Closures in FFI · Michael-F-Bryan
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Michael-F-Bryan"><meta name=description content="Every now and then when using native libraries from Rust you&rsquo;ll be asked to
pass a callback across the FFI boundary. The reasons are varied, but often
this might be done to notify the caller when &ldquo;interesting&rdquo; things happen, for
injecting logic (see the Strategy Pattern), or to handle the
result of an asynchronous operation.
If this were normal Rust, we&rsquo;d just accept a closure (e.g. a
Box<dyn Fn(...)> or by being generic over any function-like type) and be
done with it. However, when working with other languages you are reduced to
the lowest common denominator, a the C language (or more specifically, the
ABI and machine code in general) doesn&rsquo;t understand generics or Rust&rsquo;s &ldquo;fat&rdquo;
pointers."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust Closures in FFI"><meta name=twitter:description content="Every now and then when using native libraries from Rust you’ll be asked to pass a callback across the FFI boundary. The reasons are varied, but often this might be done to notify the caller when “interesting” things happen, for injecting logic (see the Strategy Pattern), or to handle the result of an asynchronous operation.
If this were normal Rust, we’d just accept a closure (e.g. a Box<dyn Fn(...)> or by being generic over any function-like type) and be done with it. However, when working with other languages you are reduced to the lowest common denominator, a the C language (or more specifically, the ABI and machine code in general) doesn’t understand generics or Rust’s “fat” pointers."><meta property="og:url" content="https://adventures.michaelfbryan.com/posts/rust-closures-in-ffi/"><meta property="og:site_name" content="Michael-F-Bryan"><meta property="og:title" content="Rust Closures in FFI"><meta property="og:description" content="Every now and then when using native libraries from Rust you’ll be asked to pass a callback across the FFI boundary. The reasons are varied, but often this might be done to notify the caller when “interesting” things happen, for injecting logic (see the Strategy Pattern), or to handle the result of an asynchronous operation.
If this were normal Rust, we’d just accept a closure (e.g. a Box<dyn Fn(...)> or by being generic over any function-like type) and be done with it. However, when working with other languages you are reduced to the lowest common denominator, a the C language (or more specifically, the ABI and machine code in general) doesn’t understand generics or Rust’s “fat” pointers."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-12T22:00:00+08:00"><meta property="article:modified_time" content="2025-04-01T09:19:10+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Unsafe Rust"><meta property="article:tag" content="FFI"><link rel=canonical href=https://adventures.michaelfbryan.com/posts/rust-closures-in-ffi/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm+MTzNJdv80k+n0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/master.min.34be5ef36a820320661b4a8578382aba472d1a01092908eb30f0db81ec4031d4.css integrity="sha256-NL5e82qCAyBmG0qFeDgqukctGgEJKQjrMPDbgexAMdQ=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://adventures.michaelfbryan.com/>Michael-F-Bryan
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://adventures.michaelfbryan.com/posts/rust-closures-in-ffi/>Rust Closures in FFI</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2020-05-12T22:00:00+08:00>May 12, 2020
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
12-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/rust/>Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/unsafe-rust/>Unsafe Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/ffi/>FFI</a></span></div></div></header><div class=post-content><p>Every now and then when using native libraries from Rust you&rsquo;ll be asked to
pass a callback across the FFI boundary. The reasons are varied, but often
this might be done to notify the caller when &ldquo;interesting&rdquo; things happen, for
injecting logic (see the <a href=https://sourcemaking.com/design_patterns/strategy class=external-link target=_blank rel=noopener>Strategy Pattern</a>), or to handle the
result of an asynchronous operation.</p><p>If this were normal Rust, we&rsquo;d just accept a closure (e.g. a
<code>Box&lt;dyn Fn(...)></code> or by being generic over any function-like type) and be
done with it. However, when working with other languages you are reduced to
the lowest common denominator, a the C language (or more specifically, the
ABI and machine code in general) doesn&rsquo;t understand generics or Rust&rsquo;s &ldquo;fat&rdquo;
pointers.</p><p>This means we need to be a little&mldr; creative.</p><div class="notices note"><p>The code written in this article is available <a href=https://github.com/Michael-F-Bryan/rust-closures-and-ffi class=external-link target=_blank rel=noopener>on GitHub</a>. Feel free to
browse through and steal code or inspiration.</p><p>If you found this useful or spotted a bug, let me know on the blog&rsquo;s
<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/issues class=external-link target=_blank rel=noopener>issue tracker</a>!</p></div><h2 id=a-simple-example>A Simple Example
<a class=heading-link href=#a-simple-example><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Let&rsquo;s look at a simple C function which adds two numbers and will let the caller
know the result by invoking a callback.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// native/simple.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span> (<span style=color:#f92672>*</span>AddCallback)(<span style=color:#66d9ef>int</span> result);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>simple_add_two_numbers</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, AddCallback cb)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cb</span>(result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices note"><p>To help make things cleaner, I&rsquo;ve pulled the callback&rsquo;s signature out into the
<code>AddCallback</code> typedef.</p><p>I don&rsquo;t know about you, but I always get confused when looking at the way to
write function pointers in C, and writing it inline as a function&rsquo;s argument
tends to turn its signature into a mess of <code>(</code>s and <code>*</code>s.</p><p>The equivalent without the <code>AddCallback</code> typedef would be this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>simple_add_two_numbers</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>cb)(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)) { ... }
</span></span></code></pre></div></div><p>The straightforward way to use <code>simple_add_two_numbers()</code> from Rust is to
define a function with the correct signature&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/simple.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_two_numbers_added</span>(result: <span style=color:#a6e22e>c_int</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Got </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>!&#34;</span>, result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>&mldr; And pass it to the native function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// examples/straightforward_simple.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> rust_closures_and_ffi::simple::{
</span></span><span style=display:flex><span>    on_two_numbers_added, simple_add_two_numbers,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Adding </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> and </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, a, b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        simple_add_two_numbers(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, on_two_numbers_added);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices note"><p>To make the C function callable from Rust, we need to add the corresponding
function declarations.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/simple.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::os::raw::c_int;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AddCallback</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span>(c_int);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simple_add_two_numbers</span>(a: <span style=color:#a6e22e>c_int</span>, b: <span style=color:#a6e22e>c_int</span>, cb: <span style=color:#a6e22e>AddCallback</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As most resources involving FFI will mention, we need to use <code>unsafe</code> when
invoking a native function because the <code>simple_add_two_numbers()</code> function
was written in another language, and the Rust compiler has no way of knowing
that it&rsquo;ll follow the borrow checker&rsquo;s rules.</p></div><p>We can even run this code and see what it generates.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span> cargo run --example straightforward_simple
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span></span><span style=display:flex><span>     Running `target/debug/examples/straightforward_simple`
</span></span><span style=display:flex><span>Adding 1 and 2
</span></span><span style=display:flex><span>Got 3!
</span></span></code></pre></div><p>Okay, that&rsquo;s awesome, but what if you want to do something with the result? Say
I need to go through a list of items and add them up.</p><p>Our problem is that the callback function only accepts a single integer and
doesn&rsquo;t return anything. That means there&rsquo;s no way to pass in a reference to
some <code>total</code> counter so we can add the <code>result</code> to it.</p><p>If you aren&rsquo;t able to access any state from the calling function, the only real
way to pass information around is via a <code>static</code> mutable global variable.</p><p>Here&rsquo;s one possible way to write it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// examples/simple_with_global_variable.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> rust_closures_and_ffi::simple::simple_add_two_numbers;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::os::raw::c_int;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>TOTAL</span>: <span style=color:#a6e22e>c_int</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> numbers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> i<span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> numbers[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> numbers[j];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>                simple_add_two_numbers(a, b, add_result_to_total);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The sum is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>TOTAL</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add_result_to_total</span>(result: <span style=color:#a6e22e>c_int</span>) { <span style=color:#66d9ef>TOTAL</span> <span style=color:#f92672>+=</span> result; }
</span></span></code></pre></div><p>Compiling and running:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo run --example simple_with_global_variable
</span></span><span style=display:flex><span>   Compiling rust-closures-and-ffi v0.1.0 (/home/michael/Documents/rust-closures-and-ffi)
</span></span><span style=display:flex><span>error[E0133]: use of mutable static is unsafe and requires unsafe function or block
</span></span><span style=display:flex><span>  --&gt; examples/simple_with_global_variable.rs:20:31
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>20 |     println!(&#34;The sum is {}&#34;, TOTAL);
</span></span><span style=display:flex><span>   |                               ^^^^^
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>error: aborting due to previous error
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>For more information about this error, try `rustc --explain E0133`.
</span></span><span style=display:flex><span>error: could not compile `rust-closures-and-ffi`.
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>To learn more, run the command again with --verbose.
</span></span></code></pre></div><p>Oops, we forgot that reading from a global requires <code>unsafe</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>// examples/simple_with_global_variable.rs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> fn main() {
</span></span><span style=display:flex><span>     ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-    println!(&#34;The sum is {}&#34;, TOTAL);
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    unsafe {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        println!(&#34;The sum is {}&#34;, TOTAL);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    }
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span> }
</span></span></code></pre></div><p>Let&rsquo;s try again&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo run --example simple_with_global_variable
</span></span><span style=display:flex><span>    Blocking waiting for file lock on build directory
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
</span></span><span style=display:flex><span>     Running `target/debug/examples/simple_with_global_variable`
</span></span><span style=display:flex><span>The sum is 224
</span></span></code></pre></div><p>You can see that this works but using a global variable isn&rsquo;t great, and as
the compiler reminded us, it&rsquo;s prone to data races and other foot-guns.</p><p>If this were pure Rust, we&rsquo;d just declare a <code>total</code> variable on the stack and
use a closure to update the variable with the result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> total <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    simple_add_two_numbers(a, b, <span style=color:#f92672>|</span>result<span style=color:#f92672>|</span> total <span style=color:#f92672>+=</span> result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The problem here isn&rsquo;t actually related to Rust. Whoever wrote the
<code>simple_add_two_numbers()</code> function included a big design flaw&mldr; It&rsquo;s
impossible for the callback to update state!</p><h2 id=a-better-adding-function>A Better Adding Function
<a class=heading-link href=#a-better-adding-function><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Now we know the original native function was flawed, let&rsquo;s go about fixing
it. If the original flaw is that our callback can&rsquo;t use any non-global state,
we just need to give it a way to access state from the caller.</p><p>Normally this state would be passed in by the caller as a pointer, but what
type should we be using?</p><p>In theory the caller may want to use their own custom struct as state
(imagine we need to update a text field on a GUI program), so hard-coding a
pointer to an integer won&rsquo;t really cut it.</p><p>Luckily, that&rsquo;s where C&rsquo;s <code>void *</code> pointer comes in. This says <em>&ldquo;I&rsquo;ve got a
pointer to&mldr; something&rdquo;</em> and to make that pointer all usable downstream code
will need to cast it to the desired type.</p><p>Here is the amended function for adding numbers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// native/better.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span> (<span style=color:#f92672>*</span>AddCallback)(<span style=color:#66d9ef>int</span> result, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>user_data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>better_add_two_numbers</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, AddCallback cb, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>user_data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cb</span>(result, user_data);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ve also taken the liberty of providing Rust declarations for
<code>better_add_two_numbers()</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/better.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::os::raw::{c_int, c_void};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AddCallback</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span>(c_int, <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>better_add_two_numbers</span>(
</span></span><span style=display:flex><span>        a: <span style=color:#a6e22e>c_int</span>,
</span></span><span style=display:flex><span>        b: <span style=color:#a6e22e>c_int</span>,
</span></span><span style=display:flex><span>        cb: <span style=color:#a6e22e>AddCallback</span>,
</span></span><span style=display:flex><span>        user_data: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void,
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s actually pretty straightforward to use this <code>void *</code> user data argument
for our counter. Here&rsquo;s the equivalent of our <code>simple_with_global_variable</code>
example.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// examples/better_with_counter_pointer.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> rust_closures_and_ffi::better::better_add_two_numbers;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::os::raw::{c_int, c_void};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> numbers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> total <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#66d9ef>in</span> i<span style=color:#f92672>..</span>numbers.len() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> numbers[i];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> numbers[j];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>                better_add_two_numbers(
</span></span><span style=display:flex><span>                    a,
</span></span><span style=display:flex><span>                    b,
</span></span><span style=display:flex><span>                    add_result_to_total,
</span></span><span style=display:flex><span>                    <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> total <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_int <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void,
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The sum is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, total);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add_result_to_total</span>(
</span></span><span style=display:flex><span>    result: <span style=color:#a6e22e>c_int</span>,
</span></span><span style=display:flex><span>    user_data: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void,
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> total <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> <span style=color:#f92672>*</span>(user_data <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_int);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>total <span style=color:#f92672>+=</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you squint, you&rsquo;ll notice that we didn&rsquo;t need to change much from the
global variable version. The only extra work we needed to do was casting
<code>total</code> to a <code>void *</code> when calling <code>better_add_two_numbers()</code> and then cast
it back at the top of <code>add_result_to_total()</code>.</p><p>Of course, there&rsquo;s no reason why we can only use a <code>c_int</code> for our
<code>user_data</code>. For more complex scenarios you&rsquo;ll often need to use a custom
type and update multiple members at a time.</p><p>For example, imagine we wanted to count the number of times the callback is
invoked as well as the final total.</p><p>First we create a new <code>Counter</code> type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// examples/better_with_counter_struct.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Default, Clone, PartialEq)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span>    total: <span style=color:#a6e22e>c_int</span>,
</span></span><span style=display:flex><span>    calls: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And then we can tweak the code to update our <code>Counter</code> struct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>  // examples/better_with_counter_struct.rs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  fn main() {
</span></span><span style=display:flex><span>      let numbers = [1, 2, 3, 4, 5, 6, 7];
</span></span><span style=display:flex><span><span style=color:#a6e22e>+     let mut counter = Counter::default();
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#f92672>-     let mut total = 0;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>
</span></span><span style=display:flex><span>      for i in 0..numbers.len() {
</span></span><span style=display:flex><span>          for j in i..numbers.len() {
</span></span><span style=display:flex><span>              let a = numbers[i];
</span></span><span style=display:flex><span>              let b = numbers[j];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>              unsafe {
</span></span><span style=display:flex><span>                  better_add_two_numbers(
</span></span><span style=display:flex><span>                      a,
</span></span><span style=display:flex><span>                      b,
</span></span><span style=display:flex><span>                      add_result_to_total,
</span></span><span style=display:flex><span><span style=color:#f92672>-                     &amp;mut total as *mut c_int as *mut c_void,
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+                     &amp;mut counter as *mut Counter as *mut c_void,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>                  );
</span></span><span style=display:flex><span>              }
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>-     println!(&#34;The sum is {}&#34;, total);
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+     println!(&#34;The result is {:?}&#34;, counter);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  unsafe extern &#34;C&#34; fn add_result_to_total(
</span></span><span style=display:flex><span>      result: c_int,
</span></span><span style=display:flex><span>      user_data: *mut c_void,
</span></span><span style=display:flex><span>  ) {
</span></span><span style=display:flex><span><span style=color:#f92672>-     let total = &amp;mut *(user_data as *mut c_int);
</span></span></span><span style=display:flex><span><span style=color:#f92672>-     *total += result;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+     let mut counter = &amp;mut *(user_data as *mut Counter);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+     counter.total += result;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+     counter.calls += 1;
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>  }
</span></span></code></pre></div><p>And of course, we can compile and run this code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo run --example better_with_counter_struct
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span></span><span style=display:flex><span>     Running `target/debug/examples/better_with_counter_struct`
</span></span><span style=display:flex><span>The result is Counter { total: 224, calls: 28 }
</span></span></code></pre></div><h2 id=introducing-closures>Introducing Closures
<a class=heading-link href=#introducing-closures><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In Rust, a closure is just syntactic sugar for defining a new type with some
sort of <code>call()</code> method. So in theory, we should be able to pass a closure to
native code by &ldquo;splitting&rdquo; it into its data (instance of the anonymous type)
and function (the <code>call()</code> method) parts.</p><p>The easiest way to do this is by creating a &ldquo;shim&rdquo; function which is generic
over one of the <code>Fn()</code> traits and will invoke the closure with the provided
arguments. Then we can get the data bit by taking a reference to the closure
variable and casting that to a <code>void *</code> pointer.</p><p>Using the last section&rsquo;s example, here is a function which satisfies the
<code>AddCallback</code> signature and will treat the provided <code>user_data</code> as a closure.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/better.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>trampoline</span><span style=color:#f92672>&lt;</span>F<span style=color:#f92672>&gt;</span>(result: <span style=color:#a6e22e>c_int</span>, user_data: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void)
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    F: FnMut(c_int),
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> user_data <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> <span style=color:#f92672>*</span>(user_data <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> F);
</span></span><span style=display:flex><span>    user_data(result);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now let&rsquo;s see how this <code>trampoline()</code> might be used in practice. Here I&rsquo;ve
created a simple integer variable, <code>got</code>, and a <code>closure</code> closure which will
set <code>got</code> to the <code>result</code> given to us by <code>better_add_two_numbers()</code>.</p><p>You can see that we&rsquo;ve taken a reference to the <code>closure</code> variable (which is
an instance of the anonymous struct <code>rustc</code> generated, and is currently
sitting on the stack) and done a couple pointer casts to turn it into
something we can use as our <code>user_data</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/better.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>use_the_trampoline_function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> got <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> closure <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>result: <span style=color:#a6e22e>c_int</span><span style=color:#f92672>|</span> got <span style=color:#f92672>=</span> result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>            better_add_two_numbers(
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>                trampoline,
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> closure <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> _ <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void,
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    assert_eq!(got, <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Unfortunately, <code>rustc</code> will complain if you try to use this <code>trampoline()</code>
function by itself because it can&rsquo;t infer the <code>F</code> type variable. The type
variable is completely unrelated to any of the functions inputs or outputs,
so there isn&rsquo;t any information available to type inference.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ cargo test
</span></span><span style=display:flex><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
</span></span><span style=display:flex><span>   Compiling rust-closures-and-ffi v0.1.0 (/home/michael/Documents/rust-closures-and-ffi)
</span></span><span style=display:flex><span>error[E0282]: type annotations needed
</span></span><span style=display:flex><span>  --&gt; src/better.rs:44:21
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span>44 |                     trampoline,
</span></span><span style=display:flex><span>   |                     ^^^^^^^^^^
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>error: aborting due to previous error
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>For more information about this error, try `rustc --explain E0282`.
</span></span><span style=display:flex><span>error: could not compile `rust-closures-and-ffi`.
</span></span></code></pre></div><p>To help things along, we can define a getter function which accepts a
reference to the closure as an argument (allowing type inference to figure
out what <code>F</code> is) and using <a href=https://turbo.fish/ class=external-link target=_blank rel=noopener>turbofish</a> to return a version of
<code>trampoline()</code> specialised for <code>F</code>.</p><div class="notices note"><p>The technical terminology for this is to <a href=https://doc.rust-lang.org/reference/items/functions.html#generic-functions class=external-link target=_blank rel=noopener><em>&ldquo;instantiate&rdquo;</em></a> a the
<code>trampoline</code> function with the type, <code>F</code>.</p></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// src/better.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_trampoline</span><span style=color:#f92672>&lt;</span>F<span style=color:#f92672>&gt;</span>(_closure: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>F</span>) -&gt; <span style=color:#a6e22e>AddCallback</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    F: FnMut(c_int),
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    trampoline::<span style=color:#f92672>&lt;</span>F<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And everything compiles with the new getter.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>  // src/better.rs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  #[test]
</span></span><span style=display:flex><span>  fn use_the_trampoline_function() {
</span></span><span style=display:flex><span>      let mut got = 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>          let mut closure = |result: c_int| got = result;
</span></span><span style=display:flex><span><span style=color:#a6e22e>+         let trampoline = get_trampoline(&amp;closure);
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>          unsafe {
</span></span><span style=display:flex><span>              better_add_two_numbers(
</span></span><span style=display:flex><span>                  1,
</span></span><span style=display:flex><span>                  2,
</span></span><span style=display:flex><span>                  trampoline,
</span></span><span style=display:flex><span>                  &amp;mut closure as *mut _ as *mut c_void,
</span></span><span style=display:flex><span>              );
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      assert_eq!(got, 3);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>You can see I&rsquo;ve written this as a test, so now we can be confident that
<code>1 + 2</code> does in fact equal <code>3</code> 🎉</p><p>To tie everything together, if I were trying to provide a safe interface to
<code>better_add_two_numbers()</code> it might be written like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// better.rs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Add two numbers, passing the result to the provided closure for further
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// processing.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add_two_numbers</span><span style=color:#f92672>&lt;</span>F<span style=color:#f92672>&gt;</span>(a: <span style=color:#66d9ef>i32</span>, b: <span style=color:#66d9ef>i32</span>, on_result_calculated: <span style=color:#a6e22e>F</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    F: FnMut(<span style=color:#66d9ef>i32</span>),
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsafe</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> closure <span style=color:#f92672>=</span> on_result_calculated;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> cb <span style=color:#f92672>=</span> get_trampoline(<span style=color:#f92672>&amp;</span>closure);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        better_add_two_numbers(a, b, cb, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> closure <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> _ <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices warning"><p>A very important thing to note is the function pointer returned by
<code>get_trampoline()</code> can <strong>only</strong> be used on the same closure that was passed in.</p><p>This is because our specialised <code>trampoline()</code> function will blindly cast
<code>user_data</code> to a pointer to that closure type without doing any type checks,
so if you try to use it on anything else you&rsquo;re gonna have a bad time&mldr;</p><p>It&rsquo;s important to make sure the callback is always an <code>unsafe</code> function,
making it the caller&rsquo;s responsibility to ensure the correct <code>user_data</code> is
used. You may sometimes need to compromise when the function signature is
outside of your control, but the times you need to do this are usually far
and few between, and you&rsquo;ll add big <code>SAFETY</code> comments where it&rsquo;s done.</p></div><h2 id=conclusions>Conclusions
<a class=heading-link href=#conclusions><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>While it may seem like a niche problem, and it is, when trying to write
idiomatic bindings for a native library it&rsquo;s not uncommon to deal with
callbacks.</p><p>In the past I used to use a slightly different version of <code>get_trampoline()</code>
which would return <em>both</em> the <code>trampoline</code> function pointer and <code>user_data</code>,
and it even <a href=https://docs.rs/ffi_helpers/0.2.0/ffi_helpers/fn.split_closure.html class=external-link target=_blank rel=noopener>became part</a> of my <code>ffi_helpers</code> crate. However,
after <a href=https://github.com/Michael-F-Bryan/ffi_helpers/pull/3/ class=external-link target=_blank rel=noopener>some lengthy discussion</a> with
<a href=https://github.com/danielhenrymantilla class=external-link target=_blank rel=noopener><code>@danielhenrymantilla</code></a>, I&rsquo;ve decided the above version is safer and
helps prevent callers from accidentally creating aliased mutable pointers.</p><details><summary>(Original trampoline getter)</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_trampoline</span><span style=color:#f92672>&lt;</span>F<span style=color:#f92672>&gt;</span>(closure: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> F) -&gt; (<span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void, AddCallback)
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    F: FnMut(c_int),
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    (closure <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> F <span style=color:#66d9ef>as</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> c_void, trampoline::<span style=color:#f92672>&lt;</span>F<span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2025
Michael-F-Bryan
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.
[<a href=https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/tree/dbb621a9a787b276f42c0f30165783a6aa3065a6 target=_blank rel=noopener>dbb621a</a>]</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script src=/js/mermaid.min.min.9c343a21d2c1c6ad2ffc2661e9409225290bf15165a7661b9149c9a03934034c.js integrity="sha256-nDQ6IdLBxq0v/CZh6UCSJSkL8VFlp2YbkUnJoDk0A0w="></script><script src=/js/index.min.c04ed42ce6cde47e0926ae55f072b1ff2e67af9e681a00d0ffe507800d3fd657.js integrity="sha256-wE7ULObN5H4JJq5V8HKx/y5nr55oGgDQ/+UHgA0/1lc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-M80ZBKQHKV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-M80ZBKQHKV")}</script></body></html>