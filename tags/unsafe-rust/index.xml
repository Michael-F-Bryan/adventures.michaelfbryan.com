<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unsafe Rust on Michael-F-Bryan</title><link>https://adventures.michaelfbryan.com/tags/unsafe-rust/</link><description>Recent content in Unsafe Rust on Michael-F-Bryan</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 01 Apr 2025 09:19:10 +0800</lastBuildDate><atom:link href="https://adventures.michaelfbryan.com/tags/unsafe-rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Link Time Dependency Injection</title><link>https://adventures.michaelfbryan.com/posts/the-linker-trick/</link><pubDate>Sun, 30 Mar 2025 12:59:58 +0800</pubDate><guid>https://adventures.michaelfbryan.com/posts/the-linker-trick/</guid><description>&lt;p>Have you ever been in a situation where, because of how the code is structured, it&amp;rsquo;s practically impossible to inject a dependency into the component that needs it? Even global variables - ubiquitously reviled for their ability to do &amp;ldquo;spooky action at a distance&amp;rdquo; - weren&amp;rsquo;t spooky enough.&lt;/p>
&lt;p>In this article, I&amp;rsquo;ll share a technique I discovered while working on a WebAssembly-based CAD package that allows for dependency injection at link time. This technique is particularly useful when traditional dependency injection methods aren&amp;rsquo;t available or practical.&lt;/p></description></item><item><title>Deserializing Binary Data Files in Rust</title><link>https://adventures.michaelfbryan.com/posts/deserializing-binary-data-files/</link><pubDate>Sun, 20 Jun 2021 00:30:00 +0800</pubDate><guid>https://adventures.michaelfbryan.com/posts/deserializing-binary-data-files/</guid><description>&lt;p>The other day, someone on the Rust user forums posted &lt;a href="https://users.rust-lang.org/t/deserializing-a-dat-binary-file-created-in-cpp/61263" class="external-link" target="_blank" rel="noopener">a question&lt;/a>
that really nerd-sniped me. They had data generated by a C++ program and were
wanting to load it into a Rust program, but when asked what format the data was
in the author didn&amp;rsquo;t provide some something like a JSON schema or Protobuf file,
instead they just got the definition for a C struct.&lt;/p>
&lt;p>A common method for &amp;ldquo;serializing&amp;rdquo; data in C is to create a struct and directly
write its bytes into a file, the &amp;ldquo;deserializing&amp;rdquo; is just a case of reading the
data out of the file and interpreting it as your type. This technique is
actually kinda genius when you think about it, it makes no intermediate copies
or heap allocations because the OS&amp;rsquo;s &lt;code>read()&lt;/code> function will literally write your
data to its destination, and there are no extra dependencies or complicated
serialization frameworks involved.&lt;/p></description></item><item><title>FFI-Safe Polymorphism: Thin Trait Objects</title><link>https://adventures.michaelfbryan.com/posts/ffi-safe-polymorphism-in-rust/</link><pubDate>Wed, 16 Dec 2020 02:00:00 +0800</pubDate><guid>https://adventures.michaelfbryan.com/posts/ffi-safe-polymorphism-in-rust/</guid><description>&lt;p>A while ago someone &lt;a href="https://users.rust-lang.org/t/ffi-c-file-and-good-rust-wrapper-equivalent-type/52050" class="external-link" target="_blank" rel="noopener">posted a question&lt;/a> on the Rust User Forums
asking how to achieve polymorphism in a C API and while lots of good
suggestions were made, I&amp;rsquo;d like to explore my take on things.&lt;/p>
&lt;p>As a recap, Rust provides two mechanisms for letting you write code which will
work with multiple types. These are&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Static Dispatch&lt;/strong>, where the compiler will generate multiple copies of the
function, tailor-made for each type and resolved at compile time, and&lt;/li>
&lt;li>&lt;strong>Dynamic Dispatch&lt;/strong>, where we use an extra level of indirection to only
resolve the actual implementation at runtime&lt;/li>
&lt;/ul>
&lt;p>While both mechanisms are extremely powerful and can cover almost all of your
needs in normal Rust code, they both have one drawback&amp;hellip; The actual
mechanisms used are (deliberately) unspecified and not safe for FFI.&lt;/p></description></item><item><title>Rust Closures in FFI</title><link>https://adventures.michaelfbryan.com/posts/rust-closures-in-ffi/</link><pubDate>Tue, 12 May 2020 22:00:00 +0800</pubDate><guid>https://adventures.michaelfbryan.com/posts/rust-closures-in-ffi/</guid><description>&lt;p>Every now and then when using native libraries from Rust you&amp;rsquo;ll be asked to
pass a callback across the FFI boundary. The reasons are varied, but often
this might be done to notify the caller when &amp;ldquo;interesting&amp;rdquo; things happen, for
injecting logic (see the &lt;a href="https://sourcemaking.com/design_patterns/strategy" class="external-link" target="_blank" rel="noopener">Strategy Pattern&lt;/a>), or to handle the
result of an asynchronous operation.&lt;/p>
&lt;p>If this were normal Rust, we&amp;rsquo;d just accept a closure (e.g. a
&lt;code>Box&amp;lt;dyn Fn(...)&amp;gt;&lt;/code> or by being generic over any function-like type) and be
done with it. However, when working with other languages you are reduced to
the lowest common denominator, a the C language (or more specifically, the
ABI and machine code in general) doesn&amp;rsquo;t understand generics or Rust&amp;rsquo;s &amp;ldquo;fat&amp;rdquo;
pointers.&lt;/p></description></item></channel></rss>