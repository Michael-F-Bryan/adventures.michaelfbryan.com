---
title: "Deserialising Binary Data Files in Rust"
date: "2021-06-19T17:51:35+08:00"
draft: true
---

The other day, someone on the Rust user forums posted [a question][question]
that really nerd-sniped me. They had data generated by a C++ program and were
wanting to load it into a Rust program, but when asked what format the data was
in the author provided the definition for a C-style struct.

A common method for "serialising" data in C is to create a struct and directly
write its bytes into a file, the "deserializing" is just a case of reading the
data out of the file and interpreting it as your type. This technique is
actually kinda genius when you think about it, it's the definition of zero-copy
because the OS's `read()` function will literally write your data to its
destination, and there are no extra dependencies or complicated serialisation
frameworks involved.

I'm not going to go into this format's drawbacks (there *is* a reason we use
things like [JSON][json] and [bincode][bincode] nowadays, after all) and instead
let's just focus on how to read these sorts of files.

I'll be approaching the problem from the perspective of someone who:

- Has a large number of these files and can't change the format for practical
  reasons (backwards compatibility, time constraints, etc.)
- Will be working in a safe environment with data they generated themselves
  (i.e. we know the files are in the right format and people won't be providing
  malicious input)
- It's okay if the tool crashes - nobody will die, your servers won't be hacked,
  and if push comes to shove we can always open a hex editor and deserialise the
  data by hand

{{% notice note %}}
The code written in this article is available [on GitHub][repo]. Feel free to
browse through and steal code or inspiration.

If you found this useful or spotted a bug, let me know on the blog's
[issue tracker][issue]!

[repo]: https://github.com/Michael-F-Bryan/deserializing-binary-data-files
[issue]: https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com/issues
{{% /notice %}}

## How is the Data Generated?

To give us a better idea of what we are dealing with, let's create a C program
that writes some data directly to a file.

To start with we'll define a simplified version of the original post's `spkr`
struct.

```c
// examples/main.c

typedef struct
{
    char name[2][20];
    char addr1[40];
    char addr2[40];
    char phone[16];
    uint16_t flags;
} spkr;
```

There are two largely equivalent ways to write binary data to a file, you could
use the POSIX [`write()`][write] function to write directly to a file
descriptor, or the [`fwrite()`][fwrite] function from `stdio.h` in the C
standard library.

```c
ssize_t write(int fd, const void *buf, size_t count);
size_t fwrite(const void *restrict ptr, size_t size, size_t nmemb, FILE *restrict stream);
```

Their definitions are similar, but `fwrite()` is more portable so that's what
we'll use.

If we ignore all error handling, this is how you would write a `spkr` to some
`my_speaker.dat` file:

```c
// examples/main.c

// Save a `spkr` to a file.
void save(const char *filename, const spkr *speaker)
{
    FILE *f = fopen(filename, "w");

    fwrite(speaker, sizeof(spkr), 1, f);
    fclose(f);
}
```

Like I said earlier, this method of saving data *is* simple.

Loading is equally as trivial - create a `spkr` variable on the stack, use
`fread()` to read one `spkr` worth of data into the variable from the file, then
return our new `spkr`.

```c
// examples/main.c

// Read a `spkr` from a file.
spkr load(const char *filename)
{
    FILE *f = fopen(filename, "r");

    spkr speaker = {0};
    fread(&speaker, sizeof(spkr), 1, f);
    fclose(f);

    return speaker;
}
```

Let's wrap this up in [a command-line program][main.c] so we can play around
with it and generate data for our Rust library to use.

```console
$ clang main.c -o main -Wall -Wpedantic
$ ./main
Usage:
	./main generate <output>	write some dumy data to a file
	./main load <filename>		print the contents of a file

$ ./main generate speaker.dat
$ xxd speaker.dat
00000000: 4a6f 7365 7068 0000 0000 0000 0000 0000  Joseph..........
00000010: 0000 0000 426c 6f67 7300 0000 0000 0000  ....Blogs.......
00000020: 0000 0000 0000 0000 3132 3320 4661 6b65  ........123 Fake
00000030: 2053 7472 6565 7400 0000 0000 0000 0000   Street.........
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 4e65 7720 596f 726b 0000 0000 0000 0000  New York........
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 0000 0000 0000 0000 3230 322d 3535 352d  ........202-555-
00000080: 3031 3137 0000 0000 0faa                 0117......

$ ./main load speaker.dat
Name: Joseph Blogs
Address:
	123 Fake Street
	New York
Phone: 202-555-0117
Flags: 0xAA0F
```

Okay, now we've got some dummy data and a better understanding of what we are
working. Let's get started on the Rust version.

## Make a Speaker Struct

After creating a new binary crate (`cargo new --bin
deserializing-binary-data-files`) the first order of business is creating a Rust
equivalent for `spkr`, and for this application our struct definition must
*exactly* match `spkr`. If it doesn't, our fields won't match up and we'll get
garbage.

For example, if left to its own devices the Rust compiler might decide that it
can generate more efficient code by moving the `flags` field to the front of
the struct and shuffling everything down. That would mean trying to read the
`phone` field in Rust would pick up the last 2 bytes of `addr2` and the first
14 bytes of `phone`. Not ideal.

Luckily there is a way to explicitly tell the compiler to represent a struct in
memory identically to what C would do, `#[repr(C)]`.

```rust
// src/main.rs

#[derive(Debug)]
#[repr(C)]
pub struct Speaker {
    name: [[u8; 20]; 2],
    addr1: [u8; 40],
    addr2: [u8; 40],
    phone: [u8; 16],
    flags: u16,
}
```

For this, we assume that `char` will be a single byte long. It's not
*technically* defined that way because the C standard deliberately chose to
leave it implementation defined, but with 50 years of C programs in the wild
that make this assumption it's probably safe to say this is a de-facto standard.

## Blindly Assuming the File Contains a Speaker

Next we need to do the actual "deserializing".

The `fread()` function in C could read data directly into our `spkr` variable
because it accepts a `void*` pointer as the destination, and all pointers
implicitly coerce to `void*`.

Unfortunately for us the corresponding API, the [`std::io::Read`][read] trait,
insists that our programs are type-safe and will only write into a byte buffer
(`&mut [u8]`).

Instead, when creating a `load()` constructor for loading a `Speaker` from a
reader, we can make space for a `Speaker` variable on the stack but
leave it uninitialised...

```rust
// src/main.rs

use std::{io::{Error, Read}, mem::{self, MaybeUninit}};

impl Speaker {
    pub fn load(mut reader: impl Read) -> Result<Self, Error> {
        // Create an uninitialized Speaker variable
        let mut speaker = MaybeUninit::<Speaker>::uninit();
        ...
    }
}
```

... Then tell the compiler to treat our `speaker` variable as a big byte
array that we can data into...

```rust
// src/main.rs

impl Speaker {
    pub fn load(mut reader: impl Read) -> Result<Self, Error> {
        ...

        unsafe {
            // Get a slice which treats the `speaker` variable as a byte array
            let buffer: &mut [u8] = std::slice::from_raw_parts_mut(
                speaker.as_mut_ptr().cast(),
                mem::size_of::<Speaker>(),
            );

            // Read exactly that many bytes from the reader
            reader.read_exact(buffer)?;
            ...
        }
    }
}
```

... then once we know the `speaker` has been completely filled with data from
the reader we can tell the compiler that it has been initialised and return it.

```rust
// src/main.rs

impl Speaker {
    pub fn load(mut reader: impl Read) -> Result<Self, Error> {
        ...

        unsafe {
            ...

            // Our `speaker` has now been initialized
            Ok(speaker.assume_init())
        }
    }
}
```

In Rust it's always a good idea to add a comment above your `unsafe` blocks
noting down your assumptions and why the `unsafe` block is correct and won't
break memory safety.

The primary reason for this being sound is that a `Speaker` only contains
integers and arrays of integers, and an integer is valid for all possible bit
patterns. That means it's impossible for bad inputs to break our
`Speaker::load()` function, sure it could give us data that doesn't make sense,
but we'd still have valid byte arrays in our byte array fields and a valid `i16`
in our `flags` field.

{{% notice note %}}
This assumption **isn't** correct in general.

For example, the `Speaker` struct couldn't container a string reference (`&str`)
because references must always be non-null, aligned, point at valid instances of
that type, and not outlive the things they refer to. Of the 2<sup>64</sup>
different possible bit patterns on a 64-bit machine, that may only be correct
for a small handful of values.

As such, it wouldn't be sound to give our `Speaker` a `&str` or `Vec<T>` field
unless we had some outside information which makes extra guarantees.
{{% /notice %}}

## Making Things Convenient


## Packing

## Better Alternatives

## Conclusions

---









## Making Things Convenient

Your next big hurdle will be interpreting the fields as useful string types. Printing a byte array will just show the numeric values for each of the bytes, so let's give `Speaker` some helper methods which will give us access to the various fields as strings if they are valid UTF8.

```rust
impl Speaker {
    pub fn address_line_1(&self) -> Option<&str> {
        std::str::from_utf8(&self.addr1).ok()
    }

    pub fn name(&self) -> Option<(&str, &str)> {
        let [first_name, last_name] = &self.name;

        let first_name = std::str::from_utf8(first_name).ok()?;
        let last_name = std::str::from_utf8(last_name).ok()?;

        Some((first_name, last_name))
    }
}
```

(the rest of the helper methods are left as an exercise for the reader)

Note that [`std::str::from_utf8()`](https://doc.rust-lang.org/std/str/fn.from_utf8.html) returns a `Result<&str, Utf8Error>` where the `Utf8Error` contains extra information about where it first encountered invalid UTF8 in the byte array. We don't care about that and only want to see if a valid UTF8 string is valid, so we use the `ok()` method to convert to an `Option<&str>`. We then use the `?` operator to say *"if this `Option` is `None`, return `None`, otherwise extract the wrapped value so it can be assigned to `first_name`"*.

## Packing

There is this concept called ["packing"](https://doc.rust-lang.org/nomicon/other-reprs.html#reprpacked) which is quite important in telling the compiler how to lay out our `Speaker` and `spkr` structs in memory. We are interpreting a bunch of bytes as a `Speaker` it is very important for us that `Speaker` and `spkr` are laid out identically otherwise we'll get garbage.

You see, processors really like it when things are lined up in memory correctly and they often need to do extra work when they aren't lined up (which kills performance) or will just error out altogether (which kills your program). For example, a `u8` can be placed at addresses that are multiples of 1 byte (i.e. anywhere), a `u32` can be placed at multiples of 4 bytes, and so on.

To deal with this alignment issue, compilers will insert spacing between fields to make sure they line up correctly - this is actually what the `#[repr(C)]` attribute does. If we want to tell the compiler *not* to insert this spacing we can use `#[repr(packed)]` to tell the compiler *"this struct's bytes must be **packed** together as closely as possible"*.

We get lucky here because the `cng` field is at offset 202, which is a multiple of 2 bytes, but otherwise we would need to use `#[repr(packed)]` instead of `#[repr(C)]`.

## Better Alternatives

There are a lot of better alternatives out there. If I was doing this as part of a commercial product where I didn't have full control over the input I would definitely reach for a better tool.

In this case, probably a parsing library like [`nom`](https://crates.io/crates/nom).

[question]: https://users.rust-lang.org/t/deserializing-a-dat-binary-file-created-in-cpp/61263
[bincode]: https://github.com/bincode-org/bincode
[write]: https://linux.die.net/man/3/write
[fwrite]: https://linux.die.net/man/3/fwrite
[main.c]: https://github.com/Michael-F-Bryan/deserializing-binary-data-files/blob/master/examples/main.c
[read]: https://doc.rust-lang.org/std/io/trait.Read.html
[json]: https://www.json.org/json-en.html
