---
title: "Geometric Constraint Solvers Part 1: Algebraic Expressions"
date: "2020-07-05T19:42:47+08:00"
draft: true
tags:
- Rust
- Geometric Constraint Solver
---

A really powerful tool in Computer Aided Design (CAD) is the ability to apply
*"constraints"* to your drawing. Constraints are a really powerful tool,
allowing the drafter to declare how parts of their drawing are related, then
letting the CAD program figure out how parameters can be manipulated in such
a way that

You can think of a constraint as some sort of mathematical relationship between
two or more parameters.

Some examples are:

- *"This interior angle is 45Â°"*
- *"That line is vertical"*
- *"Side A is perpendicular to side B"*

Graphically they'll be displayed something like this:

{{< figure
    src="https://raw.githubusercontent.com/solvespace/solvespace-web/dc2f3ed070d58eb827617633cd4bdc52b8c0ba00/pics/constraints-triangle-dim-2.png"
    link="http://solvespace.com/constraints.pl"
    caption="A constrained triangle in [SolveSpace](http://solvespace.com/)"
    alt="A constrained triangle in SolveSpace"
>}}

These constraints are declared mathematically, so a *"This line is vertical"*
constraint may be written as $line.start.x - line.end.x = 0$ and
$line.start.z - line.end.z = 0$ (assuming the $x$ axis is to the right and
the $z$ comes out of the page).

In response to input from the user (e.g. they click on the line and drag it
to the left), a constraint system will feed the perturbation into the system
of equations (e.g. the $line.start.y$ changes by $-0.1$ units) and based on
the available constraints and tie-breaking heuristics, it will figure out how
much each remaining variable must change. Execute at 60 FPS and you've got an
interactive, parametric CAD application.

A constraint solver is a fairly complex system, but the first step is teaching
it how to manipulate and evaluate abstract maths.

{{% notice note %}}
The code written in this article is available [on GitHub][repo]. Feel free to
browse through and steal code or inspiration.

If you found this useful or spotted a bug, let me know on the blog's
[issue tracker][issue]!

[repo]: https://github.com/Michael-F-Bryan/constraints
[issue]: https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com
{{% /notice %}}

## The Expression Tree

For this constraint solver we need a way to represent algebraic expressions like
$x - 5$ or $sin(x) + y\*y - x\*y$, and the most natural form is the [*Abstract
Syntax Tree*][ast].

In this language, an expression can be:

- A (possibly unnamed) parameter
- A floating-point constant
- A call to a function with a single argument
- Negation, and
- A binary operation (e.g. `x + y`, where `x` and `y` are the `left` and `right`
  operands, and we're using the `+` operator)

Our constraint solver is considerably less complex than a general purpose
programming language, so most of our *Abstract Syntax Tree* can fit into a
couple simple types.

```rust
// src/expr.rs

/// An expression.
#[derive(Debug, Clone, PartialEq)]
pub enum Expression {
    /// A free variable (e.g. `x`).
    Parameter(Parameter),
    /// A fixed constant (e.g. `3.14`).
    Constant(f64),
    /// An expression involving two operands.
    Binary {
        /// The left operand.
        left: Rc<Expression>,
        /// The right operand.
        right: Rc<Expression>,
        /// The binary operation being executed.
        op: BinaryOperation,
    },
    /// Negate the expression.
    Negate(Rc<Expression>),
    /// Invoke a builtin function.
    FunctionCall {
        /// The name of the function being called.
        function: SmolStr,
        /// The argument passed to this function call.
        argument: Rc<Expression>,
    },
}

/// A free variable.
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, Hash)]
pub enum Parameter {
    /// A variable with associated name.
    Named(SmolStr),
    /// An anonymous variable generated by the system.
    Anonymous { number: usize },
}

/// An operation that can be applied to two arguments.
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum BinaryOperation {
    Plus,
    Minus,
    Times,
    Divide,
}
```

This should be fairly straightforward if you are familiar with Rust, although
I'd like to direct your attention to two details...

1. Text fields use a [`smol_str::SmolStr`](https://crates.io/crates/smol_str)
   instead of a normal `String`
2. Each child node is behind a reference-counted pointer

We're using `SmolStr` for something called the [*Small String Optimisation*][sso].
This is where small amounts of text can be stored inline on the stack (in place
of the data pointer, length, and capacity fields in a normal `String`) to skip
a heap allocation and a layer of indirection.

The small string optimisation is useful when you're dealing with a large
number of small strings (like programming language identifiers) because it
helps avoid heap fragmentation and locality. Cloning a `SmolStr` is also
quite cheap because even if it isn't small, a reference-counted string
(analogous to `Arc<str>`) is used when we need to store large strings on the
heap.

A conscious design decision is to *make the AST immutable*. Most operations
applied to an `Expression` will leave part of the tree unchanged, and seeing
as we already *need* to add a layer of indirection to [prevent infinitely
sized types][infinite-size], we can use reference-counted pointers to share
common sub-expressions.

This should reduce memory usage and hopefully increase performance because
shared nodes are more likely to be in cache.

## Pretty-Printing and Other Useful Methods

## Parsing

## Expression Tree Operations

## Conclusions

[ast]: https://en.wikipedia.org/wiki/Abstract_syntax_tree
[sso]: https://stackoverflow.com/questions/10315041/meaning-of-acronym-sso-in-the-context-of-stdstring/10319672#10319672
[infinite-size]: https://stackoverflow.com/questions/25296195/why-are-recursive-struct-types-illegal-in-rust
