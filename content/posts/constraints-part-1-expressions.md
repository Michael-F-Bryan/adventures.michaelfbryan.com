---
title: "Geometric Constraint Solvers Part 1: Algebraic Expressions"
date: "2020-07-05T19:42:47+08:00"
draft: true
tags:
- Rust
- Geometric Constraint Solver
---

A really powerful tool in Computer Aided Design (CAD) is the ability to apply
*"constraints"* to your drawing. Constraints are a really powerful tool,
allowing the drafter to declare how parts of their drawing are related, then
letting the CAD program figure out how parameters can be manipulated in such
a way that

You can think of a constraint as some sort of mathematical relationship between
two or more parameters.

Some examples are:

- *"This interior angle is 45Â°"*
- *"That line is vertical"*
- *"Side A is perpendicular to side B"*

Graphically they'll be displayed something like this:

{{< figure
    src="https://raw.githubusercontent.com/solvespace/solvespace-web/dc2f3ed070d58eb827617633cd4bdc52b8c0ba00/pics/constraints-triangle-dim-2.png"
    link="http://solvespace.com/constraints.pl"
    caption="A constrained triangle in [SolveSpace](http://solvespace.com/)"
    alt="A constrained triangle in SolveSpace"
>}}

These constraints are declared mathematically, so a *"This line is vertical"*
constraint may be written as $line.start.x - line.end.x = 0$ and
$line.start.z - line.end.z = 0$ (assuming the $x$ axis is to the right and
the $z$ comes out of the page).

In response to input from the user (e.g. they click on the line and drag it
to the left), a constraint system will feed the perturbation into the system
of equations (e.g. the $line.start.y$ changes by $-0.1$ units) and based on
the available constraints and tie-breaking heuristics, it will figure out how
much each remaining variable must change. Execute at 60 FPS and you've got an
interactive, parametric CAD application.

A constraint solver is a fairly complex system, but the first step is teaching
it how to manipulate and evaluate abstract maths.

{{% notice note %}}
The code written in this article is available [on GitHub][repo]. Feel free to
browse through and steal code or inspiration.

If you found this useful or spotted a bug, let me know on the blog's
[issue tracker][issue]!

[repo]: https://github.com/Michael-F-Bryan/constraints
[issue]: https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com
{{% /notice %}}

## The Expression Tree

For this constraint solver we need a way to represent algebraic expressions like
$x - 5$ or $sin(x) + y\*y - x\*y$, and the most natural form is the [*Abstract
Syntax Tree*][ast].

In this language, an expression can be:

- A (possibly unnamed) parameter
- A floating-point constant
- A call to a function with a single argument
- Negation, and
- A binary operation (e.g. `x + y`, where `x` and `y` are the `left` and `right`
  operands, and we're using the `+` operator)

Our constraint solver is considerably less complex than a general purpose
programming language, so most of our *Abstract Syntax Tree* can fit into a
couple simple types.

```rust
// src/expr.rs

use std::rc::Rc;
use smol_str::SmolStr;

/// An expression.
#[derive(Debug, Clone, PartialEq)]
pub enum Expression {
    /// A free variable (e.g. `x`).
    Parameter(Parameter),
    /// A fixed constant (e.g. `3.14`).
    Constant(f64),
    /// An expression involving two operands.
    Binary {
        /// The left operand.
        left: Rc<Expression>,
        /// The right operand.
        right: Rc<Expression>,
        /// The binary operation being executed.
        op: BinaryOperation,
    },
    /// Negate the expression.
    Negate(Rc<Expression>),
    /// Invoke a builtin function.
    FunctionCall {
        /// The name of the function being called.
        function: SmolStr,
        /// The argument passed to this function call.
        argument: Rc<Expression>,
    },
}

/// A free variable.
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, Hash)]
pub enum Parameter {
    /// A variable with associated name.
    Named(SmolStr),
    /// An anonymous variable generated by the system.
    Anonymous { number: usize },
}

/// An operation that can be applied to two arguments.
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum BinaryOperation {
    Plus,
    Minus,
    Times,
    Divide,
}
```

This should be fairly straightforward if you are familiar with Rust, although
I'd like to direct your attention to two details...

1. Text fields use a [`smol_str::SmolStr`](https://crates.io/crates/smol_str)
   instead of a normal `String`
2. Each child node is behind a reference-counted pointer

We're using `SmolStr` for something called the [*Small String Optimisation*][sso].
This is where small amounts of text can be stored inline on the stack (in place
of the data pointer, length, and capacity fields in a normal `String`) to skip
a heap allocation and a layer of indirection.

The small string optimisation is useful when you're dealing with a large
number of small strings (like programming language identifiers) because it
helps avoid heap fragmentation and locality. Cloning a `SmolStr` is also
quite cheap because even if it isn't small, a reference-counted string
(analogous to `Arc<str>`) is used when we need to store large strings on the
heap.

A conscious design decision is to *make the AST immutable*. Most operations
applied to an `Expression` will leave part of the tree unchanged, and seeing
as we already *need* to add a layer of indirection to [prevent infinitely
sized types][infinite-size], we can use reference-counted pointers to share
common sub-expressions.

This should reduce memory usage and hopefully increase performance because
shared nodes are more likely to be in cache.

## Pretty-Printing and Other Useful Methods

To make our `Expression` type easier to work with we can implement several
traits from the standard library.

Arguably the most useful of these is `std::fmt::Display`, a mechanism for
getting the `Expression`'s human-readable form.

### Writing the Display Implementation

To help make writing parentheses and spaces in `Display` a bit easier, let's
create a temporary type for handling operator precedence.


```rust
// src/expr.rs

#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]
enum Precedence {
    Bi,
    Md,
    As,
}
```

{{% notice note %}}
The mnemonic I learned in school was *BIMDAS*, short for *Brackets*,
*Indices*, *Multiply and Divide*, and *Addition and Subtraction*. Hence the
cryptic variant names.

We don't support exponents (yet?), so it's fine for *Brackets* and *Indices* to
be in the same precedence variant.
{{% /notice %}}

We also define some helper methods for getting an `Expression`'s precedence.
In this case parameters, constants, and function calls all have the highest
possible precedence level.

```rust
// src/expr.rs

impl Expression {
    fn precedence(&self) -> Precedence {
        match self {
            Expression::Parameter(_)
            | Expression::Constant(_)
            | Expression::FunctionCall { .. } => Precedence::Bi,
            Expression::Negate(_) => Precedence::Md,
            Expression::Binary { op, .. } => op.precedence(),
        }
    }
}

impl BinaryOperation {
    fn precedence(self) -> Precedence {
        match self {
            BinaryOperation::Plus | BinaryOperation::Minus => Precedence::As,
            BinaryOperation::Times | BinaryOperation::Divide => Precedence::Md,
        }
    }
}
```

Printing a `Parameter` works by either printing the name as-is, or the
parameter number preceded by a `$` if it is anonymous (i.e. `$2`).

```rust
// src/expr.rs

use std::fmt::{self, Display, Formatter};

impl Display for Parameter {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Parameter::Named(name) => write!(f, "{}", name),
            Parameter::Anonymous { number } => write!(f, "${}", number),
        }
    }
}
```

In `Expression`'s `Display` implementation we just need to do a `match` and
use the `write!()` macro to generate the desired string for each variant.

```rust
// src/expr.rs

impl Display for Expression {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Expression::Parameter(p) => write!(f, "{}", p),
            Expression::Constant(value) => write!(f, "{}", value),
            Expression::Binary { left, right, op } => {
                write_with_precedence(op.precedence(), left, f)?;

                let middle = match op {
                    BinaryOperation::Plus => " + ",
                    BinaryOperation::Minus => " - ",
                    BinaryOperation::Times => "*",
                    BinaryOperation::Divide => "/",
                };
                write!(f, "{}", middle)?;

                write_with_precedence(op.precedence(), right, f)?;

                Ok(())
            },
            Expression::Negate(inner) => {
                write!(f, "-")?;

                write_with_precedence(
                    BinaryOperation::Times.precedence(),
                    inner,
                    f,
                )?;
                Ok(())
            },
            Expression::FunctionCall { function, argument } => {
                write!(f, "{}({})", function, argument)
            },
        }
    }
}

fn write_with_precedence(
    current_precedence: Precedence,
    expr: &Expression,
    f: &mut Formatter<'_>,
) -> fmt::Result {
    if expr.precedence() > current_precedence {
        // we need parentheses to maintain ordering
        write!(f, "({})", expr)
    } else {
        write!(f, "{}", expr)
    }
}
```

The `write_with_precedence()` helper is used to make sure our pretty-printer
respects the precedence of its operands by adding parentheses when necessary.
This prevents awkward bugs like `-(x + 3)` being printed as `-x + 3`.

We also deliberately add space before and after operators with the
`Precedence::As` precedence to help visually separate the different terms in an
expression.

The `Display` implementation is really easy to test. Just create a list of
tuples containing an `Expression` and its expected string representation,
then loop over asserting each gets formatted as desired.

{{% expand "Long table-based pretty-printer test" %}}

```rust
// src/expr.rs

#[test]
fn pretty_printing_works_similarly_to_a_human() {
    let inputs = vec![
        (Expression::Constant(3.0), "3"),
        (
            Expression::FunctionCall {
                function: "sin".into(),
                argument: Rc::new(Expression::Constant(5.0)),
            },
            "sin(5)",
        ),
        (
            Expression::Negate(Rc::new(Expression::Constant(5.0))),
            "-5",
        ),
        (
            Expression::Negate(Rc::new(Expression::FunctionCall {
                function: "sin".into(),
                argument: Rc::new(Expression::Constant(5.0)),
            })),
            "-sin(5)",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Plus,
            },
            "1 + 1",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Minus,
            },
            "1 - 1",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Times,
            },
            "1*1",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Divide,
            },
            "1/1",
        ),
        (
            Expression::Negate(Rc::new(Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Plus,
            })),
            "-(1 + 1)",
        ),
        (
            Expression::Negate(Rc::new(Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Times,
            })),
            "-1*1",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Binary {
                    left: Rc::new(Expression::Constant(1.0)),
                    right: Rc::new(Expression::Constant(2.0)),
                    op: BinaryOperation::Plus,
                }),
                right: Rc::new(Expression::Constant(3.0)),
                op: BinaryOperation::Divide,
            },
            "(1 + 2)/3",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(3.0)),
                right: Rc::new(Expression::Binary {
                    left: Rc::new(Expression::Constant(1.0)),
                    right: Rc::new(Expression::Constant(2.0)),
                    op: BinaryOperation::Times,
                }),
                op: BinaryOperation::Minus,
            },
            "3 - 1*2",
        ),
    ];

    for (expr, should_be) in inputs {
        let got = expr.to_string();
        assert_eq!(got, should_be);
    }
}
```
{{% /expand %}}

## Parsing

## Expression Tree Operations

## Conclusions

[ast]: https://en.wikipedia.org/wiki/Abstract_syntax_tree
[sso]: https://stackoverflow.com/questions/10315041/meaning-of-acronym-sso-in-the-context-of-stdstring/10319672#10319672
[infinite-size]: https://stackoverflow.com/questions/25296195/why-are-recursive-struct-types-illegal-in-rust
