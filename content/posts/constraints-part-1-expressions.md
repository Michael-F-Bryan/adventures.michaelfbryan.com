---
title: "Geometric Constraint Solvers Part 1: Algebraic Expressions"
date: "2020-07-05T19:42:47+08:00"
draft: true
tags:
- Rust
- Geometric Constraint Solver
---

A really powerful tool in Computer Aided Design (CAD) is the ability to apply
*"constraints"* to your drawing. Constraints are a really powerful tool,
allowing the drafter to declare how parts of their drawing are related, then
letting the CAD program figure out how parameters can be manipulated in such
a way that

You can think of a constraint as some sort of mathematical relationship between
two or more parameters.

Some examples are:

- *"This interior angle is 45Â°"*
- *"That line is vertical"*
- *"Side A is perpendicular to side B"*

Graphically they'll be displayed something like this:

{{< figure
    src="https://raw.githubusercontent.com/solvespace/solvespace-web/dc2f3ed070d58eb827617633cd4bdc52b8c0ba00/pics/constraints-triangle-dim-2.png"
    link="http://solvespace.com/constraints.pl"
    caption="A constrained triangle in [SolveSpace](http://solvespace.com/)"
    alt="A constrained triangle in SolveSpace"
>}}

These constraints are declared mathematically, so a *"This line is vertical"*
constraint may be written as $line.start.x - line.end.x = 0$ and
$line.start.z - line.end.z = 0$ (assuming the $x$ axis is to the right and
the $z$ comes out of the page).

In response to input from the user (e.g. they click on the line and drag it
to the left), a constraint system will feed the perturbation into the system
of equations (e.g. the $line.start.y$ changes by $-0.1$ units) and based on
the available constraints and tie-breaking heuristics, it will figure out how
much each remaining variable must change. Execute at 60 FPS and you've got an
interactive, parametric CAD application.

A constraint solver is a fairly complex system, but the first step is teaching
it how to manipulate and evaluate abstract maths.

{{% notice note %}}
The code written in this article is available [on GitHub][repo]. Feel free to
browse through and steal code or inspiration.

If you found this useful or spotted a bug, let me know on the blog's
[issue tracker][issue]!

[repo]: https://github.com/Michael-F-Bryan/constraints
[issue]: https://github.com/Michael-F-Bryan/adventures.michaelfbryan.com
{{% /notice %}}

## The Expression Tree

For this constraint solver we need a way to represent algebraic expressions like
$x - 5$ or $sin(x) + y\*y - x\*y$, and the most natural form is the [*Abstract
Syntax Tree*][ast].

In this language, an expression can be:

- A (possibly unnamed) parameter
- A floating-point constant
- A call to a function with a single argument
- Negation, and
- A binary operation (e.g. `x + y`, where `x` and `y` are the `left` and `right`
  operands, and we're using the `+` operator)

Our constraint solver is considerably less complex than a general purpose
programming language, so most of our *Abstract Syntax Tree* can fit into a
couple simple types.

```rust
// src/expr.rs

use std::rc::Rc;
use smol_str::SmolStr;

/// An expression.
#[derive(Debug, Clone, PartialEq)]
pub enum Expression {
    /// A free variable (e.g. `x`).
    Parameter(Parameter),
    /// A fixed constant (e.g. `3.14`).
    Constant(f64),
    /// An expression involving two operands.
    Binary {
        /// The left operand.
        left: Rc<Expression>,
        /// The right operand.
        right: Rc<Expression>,
        /// The binary operation being executed.
        op: BinaryOperation,
    },
    /// Negate the expression.
    Negate(Rc<Expression>),
    /// Invoke a builtin function.
    FunctionCall {
        /// The name of the function being called.
        name: SmolStr,
        /// The argument passed to this function call.
        argument: Rc<Expression>,
    },
}

/// A free variable.
#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Eq, Hash)]
pub enum Parameter {
    /// A variable with associated name.
    Named(SmolStr),
    /// An anonymous variable generated by the system.
    Anonymous { number: usize },
}

/// An operation that can be applied to two arguments.
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum BinaryOperation {
    Plus,
    Minus,
    Times,
    Divide,
}
```

This should be fairly straightforward if you are familiar with Rust, although
I'd like to direct your attention to two details...

1. Text fields use a [`smol_str::SmolStr`](https://crates.io/crates/smol_str)
   instead of a normal `String`
2. Each child node is behind a reference-counted pointer

We're using `SmolStr` for something called the [*Small String Optimisation*][sso].
This is where small amounts of text can be stored inline on the stack (in place
of the data pointer, length, and capacity fields in a normal `String`) to skip
a heap allocation and a layer of indirection.

The small string optimisation is useful when you're dealing with a large
number of small strings (like programming language identifiers) because it
helps avoid heap fragmentation and locality. Cloning a `SmolStr` is also
quite cheap because even if it isn't small, a reference-counted string
(analogous to `Arc<str>`) is used when we need to store large strings on the
heap.

A conscious design decision is to *make the AST immutable*. Most operations
applied to an `Expression` will leave part of the tree unchanged, and seeing
as we already *need* to add a layer of indirection to [prevent infinitely
sized types][infinite-size], we can use reference-counted pointers to share
common sub-expressions.

This should reduce memory usage and hopefully increase performance because
shared nodes are more likely to be in cache.

## Pretty-Printing and Other Useful Methods

To make our `Expression` type easier to work with we can implement several
traits from the standard library.

Arguably the most useful of these is `std::fmt::Display`, a mechanism for
getting the `Expression`'s human-readable form.

### Writing the Display Implementation

To help make writing parentheses and spaces in `Display` a bit easier, let's
create a temporary type for handling operator precedence.


```rust
// src/expr.rs

#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]
enum Precedence {
    Bi,
    Md,
    As,
}
```

{{% notice note %}}
The mnemonic I learned in school was *BIMDAS*, short for *Brackets*,
*Indices*, *Multiply and Divide*, and *Addition and Subtraction*. Hence the
cryptic variant names.

We don't support exponents (yet?), so it's fine for *Brackets* and *Indices* to
be in the same precedence variant.
{{% /notice %}}

We also define some helper methods for getting an `Expression`'s precedence.
In this case parameters, constants, and function calls all have the highest
possible precedence level.

```rust
// src/expr.rs

impl Expression {
    fn precedence(&self) -> Precedence {
        match self {
            Expression::Parameter(_)
            | Expression::Constant(_)
            | Expression::FunctionCall { .. } => Precedence::Bi,
            Expression::Negate(_) => Precedence::Md,
            Expression::Binary { op, .. } => op.precedence(),
        }
    }
}

impl BinaryOperation {
    fn precedence(self) -> Precedence {
        match self {
            BinaryOperation::Plus | BinaryOperation::Minus => Precedence::As,
            BinaryOperation::Times | BinaryOperation::Divide => Precedence::Md,
        }
    }
}
```

Printing a `Parameter` works by either printing the name as-is, or the
parameter number preceded by a `$` if it is anonymous (i.e. `$2`).

```rust
// src/expr.rs

use std::fmt::{self, Display, Formatter};

impl Display for Parameter {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Parameter::Named(name) => write!(f, "{}", name),
            Parameter::Anonymous { number } => write!(f, "${}", number),
        }
    }
}
```

In `Expression`'s `Display` implementation we just need to do a `match` and
use the `write!()` macro to generate the desired string for each variant.

```rust
// src/expr.rs

impl Display for Expression {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Expression::Parameter(p) => write!(f, "{}", p),
            Expression::Constant(value) => write!(f, "{}", value),
            Expression::Binary { left, right, op } => {
                write_with_precedence(op.precedence(), left, f)?;

                let middle = match op {
                    BinaryOperation::Plus => " + ",
                    BinaryOperation::Minus => " - ",
                    BinaryOperation::Times => "*",
                    BinaryOperation::Divide => "/",
                };
                write!(f, "{}", middle)?;

                write_with_precedence(op.precedence(), right, f)?;

                Ok(())
            },
            Expression::Negate(inner) => {
                write!(f, "-")?;

                write_with_precedence(
                    BinaryOperation::Times.precedence(),
                    inner,
                    f,
                )?;
                Ok(())
            },
            Expression::FunctionCall { name, argument } => {
                write!(f, "{}({})", name, argument)
            },
        }
    }
}

fn write_with_precedence(
    current_precedence: Precedence,
    expr: &Expression,
    f: &mut Formatter<'_>,
) -> fmt::Result {
    if expr.precedence() > current_precedence {
        // we need parentheses to maintain ordering
        write!(f, "({})", expr)
    } else {
        write!(f, "{}", expr)
    }
}
```

The `write_with_precedence()` helper is used to make sure our pretty-printer
respects the precedence of its operands by adding parentheses when necessary.
This prevents awkward bugs like `-(x + 3)` being printed as `-x + 3`.

We also deliberately add space before and after operators with the
`Precedence::As` precedence to help visually separate the different terms in an
expression.

The `Display` implementation is really easy to test. Just create a list of
tuples containing an `Expression` and its expected string representation,
then loop over asserting each gets formatted as desired.

{{% expand "Long table-based pretty-printer test" %}}

```rust
// src/expr.rs

#[test]
fn pretty_printing_works_similarly_to_a_human() {
    let inputs = vec![
        (Expression::Constant(3.0), "3"),
        (
            Expression::FunctionCall {
                name: "sin".into(),
                argument: Rc::new(Expression::Constant(5.0)),
            },
            "sin(5)",
        ),
        (
            Expression::Negate(Rc::new(Expression::Constant(5.0))),
            "-5",
        ),
        (
            Expression::Negate(Rc::new(Expression::FunctionCall {
                name: "sin".into(),
                argument: Rc::new(Expression::Constant(5.0)),
            })),
            "-sin(5)",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Plus,
            },
            "1 + 1",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Minus,
            },
            "1 - 1",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Times,
            },
            "1*1",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Divide,
            },
            "1/1",
        ),
        (
            Expression::Negate(Rc::new(Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Plus,
            })),
            "-(1 + 1)",
        ),
        (
            Expression::Negate(Rc::new(Expression::Binary {
                left: Rc::new(Expression::Constant(1.0)),
                right: Rc::new(Expression::Constant(1.0)),
                op: BinaryOperation::Times,
            })),
            "-1*1",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Binary {
                    left: Rc::new(Expression::Constant(1.0)),
                    right: Rc::new(Expression::Constant(2.0)),
                    op: BinaryOperation::Plus,
                }),
                right: Rc::new(Expression::Constant(3.0)),
                op: BinaryOperation::Divide,
            },
            "(1 + 2)/3",
        ),
        (
            Expression::Binary {
                left: Rc::new(Expression::Constant(3.0)),
                right: Rc::new(Expression::Binary {
                    left: Rc::new(Expression::Constant(1.0)),
                    right: Rc::new(Expression::Constant(2.0)),
                    op: BinaryOperation::Times,
                }),
                op: BinaryOperation::Minus,
            },
            "3 - 1*2",
        ),
    ];

    for (expr, should_be) in inputs {
        let got = expr.to_string();
        assert_eq!(got, should_be);
    }
}
```
{{% /expand %}}

### Operator Overloads

The use of operator overloads can often be quite controversial, but in this
case I think it could help add some level of [*syntactic sugar*][sugar] to
make constructing `Expression`s more readable.

In this case, we'll overload the normal binary operators so they wrap the left
and right operands with an `Expression::Binary`.

```rust
// src/expr.rs

use std::ops::{Add, Div, Mul, Sub};

// define some operator overloads to make constructing an expression easier.

impl Add for Expression {
    type Output = Expression;

    fn add(self, rhs: Expression) -> Expression {
        Expression::Binary {
            left: Rc::new(self),
            right: Rc::new(rhs),
            op: BinaryOperation::Plus,
        }
    }
}

impl Sub for Expression {
    type Output = Expression;

    fn sub(self, rhs: Expression) -> Expression {
        Expression::Binary {
            left: Rc::new(self),
            right: Rc::new(rhs),
            op: BinaryOperation::Minus,
        }
    }
}

impl Mul for Expression {
    type Output = Expression;

    fn mul(self, rhs: Expression) -> Expression {
        Expression::Binary {
            left: Rc::new(self),
            right: Rc::new(rhs),
            op: BinaryOperation::Times,
        }
    }
}

impl Div for Expression {
    type Output = Expression;

    fn div(self, rhs: Expression) -> Expression {
        Expression::Binary {
            left: Rc::new(self),
            right: Rc::new(rhs),
            op: BinaryOperation::Divide,
        }
    }
}
```

While we're at it, let's add a `Neg` impl so you can write things like `-x`.

```rust
// src/expr.rs

use std::ops::Neg;

impl Neg for Expression {
    type Output = Expression;

    fn neg(self) -> Self::Output { Expression::Negate(Rc::new(self)) }
}
```

You can see none of these operator overloads are particularly interesting, they
just let us avoid a bunch of typing.

### Iterators

A useful building block for working with the `Expression` tree is being able
to iterate over every node in the tree. Imagine scanning through a big
expression to figure out which parameters it references or the functions that
it calls.

To do this, we'll create an `iter()` method which returns something
implementing `Iterator<Item = &Expression>`.

```rust
// src/expr.rs

impl Expression {
    /// Iterate over all [`Expression`]s in this [`Expression`] tree.
    pub fn iter(&self) -> impl Iterator<Item = &Expression> + '_ {
        Iter {
            to_visit: vec![self],
        }
    }
}

/// A depth-first iterator over the sub-[`Expression`]s in an [`Expression`].
#[derive(Debug)]
struct Iter<'expr> {
    to_visit: Vec<&'expr Expression>,
}
```

The `Iter` type works by maintaining a list of `&Expression` references for the
nodes it still needs to visit. Getting the `next_item` is then just a case of
popping a reference from the list, queueing any sub-expressions under
`next_item` itself before returning it.

```rust
// src/expr.rs

impl<'expr> Iterator for Iter<'expr> {
    type Item = &'expr Expression;

    fn next(&mut self) -> Option<Self::Item> {
        let next_item = self.to_visit.pop()?;

        match next_item {
            Expression::Binary { left, right, .. } => {
                self.to_visit.push(right);
                self.to_visit.push(left);
            },
            Expression::Negate(inner) => self.to_visit.push(inner),
            Expression::FunctionCall { argument, .. } => {
                self.to_visit.push(argument)
            },
            _ => {},
        }

        Some(next_item)
    }
}
```

This enables nice things like an iterator over all referenced parameters or
functions, and checking whether an expression depends on a parameter.

```rust
// src/expr.rs

impl Expression {
    /// Iterate over all [`Parameter`]s mentioned in this [`Expression`].
    pub fn params(&self) -> impl Iterator<Item = &Parameter> + '_ {
        self.iter().filter_map(|expr| match expr {
            Expression::Parameter(p) => Some(p),
            _ => None,
        })
    }

    /// Does this [`Expression`] involve a particular [`Parameter`]?
    pub fn depends_on(&self, param: &Parameter) -> bool {
        self.params().any(|p| p == param)
    }

    /// Iterate over all functions used by this [`Expression`].
    pub fn functions(&self) -> impl Iterator<Item = &str> + '_ {
        self.iter().filter_map(|expr| match expr {
            Expression::FunctionCall { name, .. } => Some(name.as_ref()),
            _ => None,
        })
    }
}
```

## Parsing

An incredibly useful tool is the ability to parse an `Expression` from a string.

Besides letting the user input enter an expression into the computer in
textual form, it can also be a powerful tool during development. In
combination with our earlier pretty-printer, you can use strings to concisely
say what an `Expression` should look like before and after a particular
operation.

Throw in a macro or two and a suite of unit tests could look like this:

```rust
expr_test!(simplify_multiplication, "2*2 + x" => fold_constants => "4 + x");
expr_test!(simplify_sine_90, "sin(90)" => fold_constants => "1");
expr_test!(differentiate_cos, "cos(t)" => partial_derivative(t) => "-sin(t)");
expr_test!(evaluate_tricky_expression, "10 - 2*x + x*x" => evaluate(x: 5.0) => "25");
```

The process of turning unstructured text into a more structured form, an
`Expression` tree in our case, is commonly referred to as *"parsing"*.

To make things simpler I'm going to apply a pre-processing step called
[*Tokenisation*][tokenise] which breaks the string up into the "atoms" of our
language. These are things like identifiers (`"foo"`), numbers (`"3.14"`),
punctuation (`"("`), and operators (`"+"`).

### Tokenising

A `Token` is a string which has been categorised and knows where it
occurred in the original body of text (for diagnostic purposes).

```rust
// src/parse.rs

use std::ops::Range;

#[derive(Debug, Clone, PartialEq)]
struct Token<'a> {
    text: &'a str,
    span: Range<usize>,
    kind: TokenKind,
}

/// The kinds of token that can appear in an [`Expression`]'s text form.
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum TokenKind {
    Identifier,
    Number,
    OpenParen,
    CloseParen,
    Plus,
    Minus,
    Times,
    Divide,
}
```

We use the `Iterator` trait to represent a stream of tokens. For our purposes,
a `Tokens` stream wraps a `&str` and uses a cursor to keep track of where it
has read up to. I've attached a couple helper methods for seeing what text is
remaining.

```rust
// src/parse.rs

#[derive(Debug, Clone, PartialEq)]
struct Tokens<'a> {
    src: &'a str,
    cursor: usize,
}

impl<'a> Tokens<'a> {
    fn new(src: &'a str) -> Self { Tokens { src, cursor: 0 } }

    fn rest(&self) -> &'a str { &self.src[self.cursor..] }

    fn peek(&self) -> Option<char> { self.rest().chars().next() }
}
```

While it's nice to see what text is remaining, we also need a way to advance
the `cursor` along the string.

```rust
// src/parse.rs

impl<'a> Tokens<'a> {
    fn advance(&mut self) -> Option<char> {
        let c = self.peek()?;
        self.cursor += c.len_utf8();
        Some(c)
    }
}
```

If you wanted to, you could implement the rest of the `Tokens` type purely using
calls to `peek()` and `advance()`, but sometimes it's easier to have a more
high-level primitive.

For this sort of thing I'll typically use some sort of `take_while()` method
which accepts a predicate and will keep advancing the `cursor` until the
predicate doesn't like the next character in line.

```rust
// src/parse.rs

impl<'a> Tokens<'a> {
    fn take_while<P>(
        &mut self,
        mut predicate: P,
    ) -> Option<(&'a str, Range<usize>)>
    where
        P: FnMut(char) -> bool,
    {
        let start = self.cursor;

        while let Some(c) = self.peek() {
            if !predicate(c) { break; }

            self.advance();
        }

        let end = self.cursor;

        if start != end {
            let text = &self.src[start..end];
            Some((text, start..end))
        } else {
            None
        }
    }
}
```

{{% notice note %}}
By stashing away the `cursor`'s value before and after looping we can
calculate the range of characters that have been consumed, and whether
anything was consumed at all.
{{% /notice %}}

## Expression Tree Operations

## Conclusions

[ast]: https://en.wikipedia.org/wiki/Abstract_syntax_tree
[sso]: https://stackoverflow.com/questions/10315041/meaning-of-acronym-sso-in-the-context-of-stdstring/10319672#10319672
[infinite-size]: https://stackoverflow.com/questions/25296195/why-are-recursive-struct-types-illegal-in-rust
[sugar]: https://en.wikipedia.org/wiki/Syntactic_sugar
[tokenise]: https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization
